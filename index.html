<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JOLI reference · JOLI Reference</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JOLI Reference</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>JOLI reference</a><ul class="internal"><li><a class="tocitem" href="#Module"><span>Module</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Constants"><span>Constants</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JOLI reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JOLI reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JOLI.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JOLI-reference"><a class="docs-heading-anchor" href="#JOLI-reference">JOLI reference</a><a id="JOLI-reference-1"></a><a class="docs-heading-anchor-permalink" href="#JOLI-reference" title="Permalink"></a></h1><ul><li><a href="#JOLI-reference">JOLI reference</a></li><ul><li><a href="#Module">Module</a></li><li><a href="#Types">Types</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Constants">Constants</a></li><li><a href="#Macros">Macros</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Module"><a class="docs-heading-anchor" href="#Module">Module</a><a id="Module-1"></a><a class="docs-heading-anchor-permalink" href="#Module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JOLI.JOLI" href="#JOLI.JOLI"><code>JOLI.JOLI</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Julia Operator LIbrary (JOLI) is a package for creating algebraic operators (currently linear only) and use them in a way that tries to mimic the mathematical formulas of basics algebra.</p><p>The package was created in SLIM group at the University of British Columbia for their work in seismic imaging and modelling.</p><p>JOLI has a collection of methods that allow creating and use of element-free operators, operators created from explicit Matrices, and composing all of those into complex formulas that are not explicitly executed until they act on the Vector or Matrix. &#39;*&#39;, &#39;+&#39;, &#39;-&#39; and etc... operations are supported in any mathematically valid combination of operators and vectors as long as vector is on the right side of the operator. Composite operators can be defined before they are used to act on vectors.</p><p>JOLI operators support operations like adjoint, transpose, and conjugate for element-free operators provided that enough functionality is provided when constructing JOLI operator.</p><p>JOLI operators support and enforce consistency of domain and range data types for operators with both vectors acted upon and created by operators. JOLI also has the functionality that allows easily to switch precision of computations using global type definitions.</p><p>Contrary to other linear-operators Julia packages, JOLI operators act on matrices as if those were column-wise collections of vectors. I.e. JOLI operator does not treat explicit matrix on left side of &#39;*&#39; as another operator, and will act on it immediately. Such behaviour is convenient for implementation of Kronecker product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/JOLI.jl#L5-L38">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JOLI.joCoreBlock-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WT}, Tuple{OT}} where WT&lt;:Number where OT&lt;:Integer" href="#JOLI.joCoreBlock-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WT}, Tuple{OT}} where WT&lt;:Number where OT&lt;:Integer"><code>JOLI.joCoreBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joCoreBlock(op1[,op2][,...];
    [moffsets=...,][noffsets=...,][weights=...,]
    [mextend=...,][nextend=...,][name=...])</code></pre><p>Universal (Core) block operator composed from serial JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joCoreBlock(ops::joAbstractLinearOperator...;
    moffsets::LocalVector{Integer},noffsets::LocalVector{Integer},
    weights::LocalVector,mextend::Integer,nextend::Integer,name::String)</code></pre><p><strong>Arguments</strong></p><ul><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>moffsets</code>: vector of starting indecies in 1st dimansion</li><li><code>noffsets</code>: vector of starting indecies in 2nd dimansion</li><li><code>weights</code>: vector of waights for each operator</li><li><code>mextend</code>: size of zero extension in 1st dimension</li><li><code>nextend</code>: size of zero extension in 2nd dimension</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all given operators must have same domain/range types</li><li>the domain/range types of joCoreBlock are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,4,5);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)

b=rand(ComplexF64,7,8);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)

c=rand(ComplexF64,6,8);
C=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=&quot;C&quot;)</code></pre><p>define supporting vectors for more complex blocks</p><pre><code class="language-none">moff=[0;5;13]
noff=[0;6;15]
w=rand(ComplexF64,3)</code></pre><p>basic diagonal-corners adjacent blocks</p><pre><code class="language-none">BD=joCoreBlock(A,B,C)</code></pre><p>sparse blocks</p><pre><code class="language-none">BD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff)</code></pre><p>sparse blocks with zero extansion of (mextend,nextend) size</p><pre><code class="language-none">BD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff,mextend=5,nextend=5)</code></pre><p>weighted basic diagonal-corners adjacent blocks</p><pre><code class="language-none">BD=joCoreBlock(A,B,C;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlock.jl#L8-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDALinearOperator" href="#JOLI.joDALinearOperator"><code>JOLI.joDALinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joDALinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelLinearOperator.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistribute" href="#JOLI.joDAdistribute"><code>JOLI.joDAdistribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">joDAdistribute is DAarray toggle type &amp; constructor

!!! Do not use it to create the operators</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelToggleOperator.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer" href="#JOLI.joDAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joDAdistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joDAdistribute(m [,parts]; [DT])
julia&gt; joDAdistribute(wpool, m [,parts]; [DT])
julia&gt; joDAdistribute(m, nvc [,parts]; [DT])
julia&gt; joDAdistribute(wpool, m, nvc [,parts]; [DT])
julia&gt; joDAdistribute(dst)
julia&gt; joDAdistribute(DA)</code></pre><p>defines operator to distribute serial vector into DistributedArrays&#39; vector</p><p><strong>Signature</strong></p><pre><code class="language-none">joDAdistribute(m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);
    kwargs...) where INT&lt;:Integer
joDAdistribute(wpool::WorkerPool,m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joDAdistribute(m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    kwargs...) where INT&lt;:Integer
joDAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joDAdistribute(dst::joPAsetup;gclean::Bool=false)
joDAdistribute(A::joDAdistributedLinearOperator;gclean::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: length of the vector</li><li><code>nvc</code>: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension</li><li><code>parts</code>: custom partitioning of distributed dimension</li><li><code>wpool</code>: custom WorkerPool</li><li><code>DT</code>: DataType for joPAsetup</li><li><code>dst</code>: joPAsetup</li><li><code>DA</code>: joDAdistributedLinearOperator</li><li><code>glcean</code>: clean DArray after gathering</li></ul><p><strong>Notes</strong></p><ul><li>no type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)</li><li>adjoint/transpose of the joDAdistribute will gather distributed vector into serial vector</li></ul><p><strong>Examples</strong></p><ul><li><code>joDAdistribute(5)</code>: distribute vector of lenght 5 into default WorkerPool</li><li><code>joDAdistribute(5,2)</code>: distribute multi-vector of lenght 5 with 2 columns into default WorkerPool</li><li><code>joDAdistribute(5)&#39;</code>: gather vector of lenght 5</li><li><code>joDAdistribute(5,2)&#39;</code>: gather multi-vector of lenght 5 with 2 columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractDAparallelToggleOperator/constructors.jl#L9-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistributedLinearOperator" href="#JOLI.joDAdistributedLinearOperator"><code>JOLI.joDAdistributedLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joDAdistributedLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelLinearOperator.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistributingLinearOperator" href="#JOLI.joDAdistributingLinearOperator"><code>JOLI.joDAdistributingLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joDAdistributingLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelLinearOperator.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAgather" href="#JOLI.joDAgather"><code>JOLI.joDAgather</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">joDAgather is DAarray toggle type &amp; constructor

!!! Do not use it to create the operators</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelToggleOperator.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer" href="#JOLI.joDAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joDAgather</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joDAgather(m [,parts]; [DT])
julia&gt; joDAgather(wpool, m [,parts]; [DT])
julia&gt; joDAgather(m, nvc [,parts]; [DT])
julia&gt; joDAgather(wpool, m, nvc [,parts]; [DT])
julia&gt; joDAgather(dst)
julia&gt; joDAgather(DA)</code></pre><p>defines operator to gather DistributedArrays&#39; vector into serial vector</p><p><strong>Signature</strong></p><pre><code class="language-none">joDAgather(m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);
    kwargs...) where INT&lt;:Integer
joDAgather(wpool::WorkerPool,m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joDAgather(m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    kwargs...) where INT&lt;:Integer
joDAgather(wpool::WorkerPool,m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joDAgather(dst::joPAsetup;gclean::Bool=false)
joDAgather(A::joDAdistributedLinearOperator;gclean::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: length of the vector</li><li><code>nvc</code>: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension</li><li><code>parts</code>: custom partitioning of distributed dimension</li><li><code>wpool</code>: custom WorkerPool</li><li><code>DT</code>: DataType for joPAsetup</li><li><code>dst</code>: joPAsetup</li><li><code>DA</code>: joDAdistributedLinearOperator</li><li><code>glcean</code>: clean DArray after gathering</li></ul><p><strong>Notes</strong></p><ul><li>no type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)</li><li>adjoint/transpose of the joDAgather will distribute serial vector into DistributedArrays&#39; vector</li></ul><p><strong>Examples</strong></p><ul><li><code>joDAgather(5)</code>: gather vector of lenght 5</li><li><code>joDAgather(5,2)</code>: gather multi-vector of lenght 5 with 2 columns</li><li><code>joDAgather(5)&#39;</code>: distribute vector of lenght 5 into default WorkerPool</li><li><code>joDAgather(5,2)&#39;</code>: distribute multi-vector of lenght 5 with 2 columns into default WorkerPool</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractDAparallelToggleOperator/constructors.jl#L112-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAgatheringLinearOperator" href="#JOLI.joDAgatheringLinearOperator"><code>JOLI.joDAgatheringLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joDAgatheringLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractDAparallelLinearOperator.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joKron-Tuple{Vararg{joAbstractLinearOperator,N} where N}" href="#JOLI.joKron-Tuple{Vararg{joAbstractLinearOperator,N} where N}"><code>JOLI.joKron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joKron(op1[,op2][,...];[name=...])</code></pre><p>Kronecker product of serial JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joKron(ops::joAbstractLinearOperator...;name::String=&quot;joKron&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>the domain and range types of joKron are equal respectively to domain type of rightmost operator and range type of leftmost operator</li><li>all operators in the chain must have consistent passing domain/range types, i.e. domain type of operator on the left have to be the same as range type of operator on the right</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,6,4);
A=joMatrix(a;name=&quot;A&quot;)

b=rand(ComplexF64,6,8);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)

c=rand(ComplexF64,6,4);
C=joMatrix(c;DDT=ComplexF64,RDT=ComplexF32,name=&quot;C&quot;)</code></pre><p>define Kronecker product</p><pre><code class="language-none">K=joKron(A,B,C)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joKron.jl#L8-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunction" href="#JOLI.joLinearFunction"><code>JOLI.joLinearFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLinearFunction type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward function</li><li>fop_T::Nullable{Function} : transpose function</li><li>fop_A::Nullable{Function} : adjoint function</li><li>fop_C::Nullable{Function} : conj function</li><li>fMVok : whether fops are rady to handle mvec</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li><li>iop<em>C::Nullable{Function} : inverse for fop</em>C</li><li>iMVok::Bool : whether iops are rady to handle mvec</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperator.jl#L88-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplace" href="#JOLI.joLinearFunctionInplace"><code>JOLI.joLinearFunctionInplace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLinearFunctionInplace type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward function</li><li>fop_T::Nullable{Function} : transpose function</li><li>fop_A::Nullable{Function} : adjoint function</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperatorInplace.jl#L101-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearOperator" href="#JOLI.joLinearOperator"><code>JOLI.joLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperator.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunction" href="#JOLI.joLooseLinearFunction"><code>JOLI.joLooseLinearFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLooseLinearFunction type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward function</li><li>fop_T::Nullable{Function} : transpose function</li><li>fop_A::Nullable{Function} : adjoint function</li><li>fop_C::Nullable{Function} : conj function</li><li>fMVok : whether fops are rady to handle mvec</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li><li>iop<em>C::Nullable{Function} : inverse for fop</em>C</li><li>iMVok::Bool : whether iops are rady to handle mvec</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractFosterLinearOperator.jl#L57-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplace" href="#JOLI.joLooseLinearFunctionInplace"><code>JOLI.joLooseLinearFunctionInplace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLooseLinearFunctionInplace type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward function</li><li>fop_T::Nullable{Function} : transpose function</li><li>fop_A::Nullable{Function} : adjoint function</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperatorInplace.jl#L145-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseMatrix" href="#JOLI.joLooseMatrix"><code>JOLI.joLooseMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLooseMatrix type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward matrix</li><li>fop_T::Function : transpose matrix</li><li>fop_A::Function : adjoint matrix</li><li>fop_C::Function : conj matrix</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li><li>iop<em>C::Nullable{Function} : inverse for fop</em>C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractFosterLinearOperator.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT" href="#JOLI.joLooseMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joLooseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joLooseMatrix outer constructor</p><pre><code class="language-none">joLooseMatrix(array::AbstractMatrix;
         DDT::DataType=eltype(array),
         RDT::DataType=promote_type(eltype(array),DDT),
         name::String=&quot;joLooseMatrix&quot;)</code></pre><p>Look up argument names in help to joLooseMatrix type.</p><p><strong>Example</strong></p><ul><li>joLooseMatrix(rand(4,3)) # implicit domain and range</li><li>joLooseMatrix(rand(4,3);DDT=Float32) # implicit range</li><li>joLooseMatrix(rand(4,3);DDT=Float32,RDT=Float64)</li><li>joLooseMatrix(rand(4,3);name=&quot;my matrix&quot;) # adding name</li></ul><p><strong>Notes</strong></p><ul><li>if DDT:&lt;Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator</li><li>if RDT:&lt;Real for complex matrix then imaginary part will be neglected for forward/conjugate operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseMatrixInplace" href="#JOLI.joLooseMatrixInplace"><code>JOLI.joLooseMatrixInplace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joLooseMatrixInplace type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward matrix</li><li>fop_T::Function : transpose matrix</li><li>fop_A::Function : adjoint matrix</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperatorInplace.jl#L57-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT" href="#JOLI.joLooseMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joLooseMatrixInplace</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joLooseMatrixInplace outer constructor</p><pre><code class="language-none">joLooseMatrixInplace(array::AbstractMatrix;
         DDT::DataType=eltype(array),
         RDT::DataType=promote_type(eltype(array),DDT),
         name::String=&quot;joLooseMatrixInplace&quot;)</code></pre><p>Look up argument names in help to joLooseMatrixInplace type.</p><p><strong>Example</strong></p><ul><li>joLooseMatrixInplace(rand(4,3)) # implicit domain and range</li><li>joLooseMatrixInplace(rand(4,3);DDT=Float32) # implicit range</li><li>joLooseMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)</li><li>joLooseMatrixInplace(rand(4,3);name=&quot;my matrix&quot;) # adding name</li></ul><p><strong>Notes</strong></p><ul><li>if DDT:&lt;Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator</li><li>if RDT:&lt;Real for complex matrix then imaginary part will be neglected for forward/conjugate operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L50-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMatrix" href="#JOLI.joMatrix"><code>JOLI.joMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joMatrix type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward matrix</li><li>fop_T::Function : transpose matrix</li><li>fop_A::Function : adjoint matrix</li><li>fop_C::Function : conj matrix</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li><li>iop<em>C::Nullable{Function} : inverse for fop</em>C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperator.jl#L42-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT" href="#JOLI.joMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joMatrix outer constructor</p><pre><code class="language-none">joMatrix(array::AbstractMatrix;
         DDT::DataType=eltype(array),
         RDT::DataType=promote_type(eltype(array),DDT),
         name::String=&quot;joMatrix&quot;)</code></pre><p>Look up argument names in help to joMatrix type.</p><p><strong>Example</strong></p><ul><li>joMatrix(rand(4,3)) # implicit domain and range</li><li>joMatrix(rand(4,3);DDT=Float32) # implicit range</li><li>joMatrix(rand(4,3);DDT=Float32,RDT=Float64)</li><li>joMatrix(rand(4,3);name=&quot;my matrix&quot;) # adding name</li></ul><p><strong>Notes</strong></p><ul><li>if DDT:&lt;Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator</li><li>if RDT:&lt;Real for complex matrix then imaginary part will be neglected for forward/conjugate operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMatrixInplace" href="#JOLI.joMatrixInplace"><code>JOLI.joMatrixInplace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joMatrixInplace type</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>name::String : given name</li><li>m::Integer : # of rows</li><li>n::Integer : # of columns</li><li>fop::Function : forward matrix</li><li>fop_T::Function : transpose matrix</li><li>fop_A::Function : adjoint matrix</li><li>fop_C::Function : conj matrix</li><li>iop::Nullable{Function} : inverse for fop</li><li>iop<em>T::Nullable{Function} : inverse for fop</em>T</li><li>iop<em>A::Nullable{Function} : inverse for fop</em>A</li><li>iop<em>C::Nullable{Function} : inverse for fop</em>C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractLinearOperatorInplace.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT" href="#JOLI.joMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joMatrixInplace</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joMatrixInplace outer constructor</p><pre><code class="language-none">joMatrixInplace(array::AbstractMatrix;
         DDT::DataType=eltype(array),
         RDT::DataType=promote_type(eltype(array),DDT),
         name::String=&quot;joMatrixInplace&quot;)</code></pre><p>Look up argument names in help to joMatrixInplace type.</p><p><strong>Example</strong></p><ul><li>joMatrixInplace(rand(4,3)) # implicit domain and range</li><li>joMatrixInplace(rand(4,3);DDT=Float32) # implicit range</li><li>joMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)</li><li>joMatrixInplace(rand(4,3);name=&quot;my matrix&quot;) # adding name</li></ul><p><strong>Notes</strong></p><ul><li>if DDT:&lt;Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator</li><li>if RDT:&lt;Real for complex matrix then imaginary part will be neglected for forward/conjugate operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joNumber" href="#JOLI.joNumber"><code>JOLI.joNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joNumber type</p><p>A number type to use for jo operations with number</p><p><strong>TYPE PARAMETERS</strong></p><ul><li>DDT::DataType : domain DataType</li><li>RDT::DataType : range DataType</li></ul><p><strong>FIELDS</strong></p><ul><li>ddt::DDT : number to use when acting on vector to return domain vector</li><li>rdt::RDT : number to use when acting on vector to return range vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joMiscTypes.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joNumber-Union{Tuple{NT}, Tuple{NT}} where NT&lt;:Number" href="#JOLI.joNumber-Union{Tuple{NT}, Tuple{NT}} where NT&lt;:Number"><code>JOLI.joNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joNumber outer constructor</p><pre><code class="language-none">joNumber(num)</code></pre><p>Create joNumber with types matching given number</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joNumber.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joNumber-Union{Tuple{RDT}, Tuple{DDT}, Tuple{NT}, Tuple{NT,joAbstractLinearOperator{DDT,RDT}}} where RDT where DDT where NT&lt;:Number" href="#JOLI.joNumber-Union{Tuple{RDT}, Tuple{DDT}, Tuple{NT}, Tuple{NT,joAbstractLinearOperator{DDT,RDT}}} where RDT where DDT where NT&lt;:Number"><code>JOLI.joNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joNumber outer constructor</p><pre><code class="language-none">joNumber(num,A::joAbstractLinearOperator{DDT,RDT})</code></pre><p>Create joNumber with types matching the given operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joNumber.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup" href="#JOLI.joPAsetup"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joPAsetup type</p><p><strong>Atributes</strong></p><ul><li>name::String        # name for identification</li><li>dims::Dims          # dimensions of the array</li><li>procs::Vector{Int}  # ids of workers to use</li><li>chunks::Vector{Int} # number of chunks in each dimension</li><li>idxs::Array{Tuple{Vararg{UnitRange{&lt;:Integer}}}}</li><li>cuts::Vector{Vector{&lt;:Integer}}</li><li>DT::DataType</li></ul><p>See help for outer constructors for joPAsetup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joPAsetup.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup-Tuple{DistributedArrays.DArray}" href="#JOLI.joPAsetup-Tuple{DistributedArrays.DArray}"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joPAsetup(in::DArray)</code></pre><p>Get joPAsetup represeanting a given DArray</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}} where INT&lt;:Integer" href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joPAsetup(wpool,n;[DT,][name])
julia&gt; joPAsetup(n;[DT,][name])</code></pre><p>Creates joPAsetup type - basic 1D distribution</p><p><strong>Signatures</strong></p><pre><code class="language-none">joPAsetup(wpool::WorkerPool,n::Integer;
    DT::DataType=joFloat,
    name::String=&quot;joPAsetup&quot;;
joPAsetup(n::Integer;kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>wpool</code>: WorkerPool instance - defaults to WorkerPool(workers())</li><li><code>n</code>: length of the vector</li><li><code>DT</code>: DataType of vector&#39;s elements</li><li><code>name</code>: name of distributor</li></ul><p><strong>Examples</strong></p><ul><li><code>joPAsetup(128)</code>: basic distributor for joFloat vector</li><li><code>joPAsetup(40;DT=Int8)</code>: basic distributor for Int8 vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L121-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N,Integer}} where INT&lt;:Integer" href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N,Integer}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joPAsetup(wpool,dims,ddim;[DT,][parts,][name])
julia&gt; joPAsetup(dims,ddim;[DT,][parts,][name])</code></pre><p>Creates joPAsetup type</p><p><strong>Signature</strong></p><pre><code class="language-none">joPAsetup(wpool::WorkerPool,dims::Dims,ddim::Integer;
    DT::DataType=joFloat,
    parts::Union{Vector{Integer},Dims}=joPAsetup_etc.balanced_partition(nworkers(wpool),dims[ddim]),
    name::String=&quot;joPAsetup&quot;,)
joPAsetup(dims::Dims,ddim::Integer;kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>wpool</code>: WorkerPool instance - defaults to WorkerPool(workers())</li><li><code>dims</code>: tuple with array&#39;s dimensions</li><li><code>ddim</code>: dimansion to distribute over</li><li><code>DT</code>: DataType of array&#39;s elements</li><li><code>parts</code>: tuple/vector of the subarray&#39;s size on each worker in distributed dimension</li><li><code>name</code>: name of distributor</li></ul><p><strong>Examples</strong></p><ul><li><code>joPAsetup((3,40,5),2;DT=Int8)</code>: distribute 2nd dimension over 4 workers</li><li><code>joPAsetup((3,40,5),2;DT=Int8,parts=(11,11,11,7))</code>: distribute 2nd dimension over 4 workers and specify parts</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L204-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N}} where INT&lt;:Integer" href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joPAsetup(wpool,dims;[DT,][chunks,][name])
julia&gt; joPAsetup(dims;[DT,][chunks,][name])</code></pre><p>Creates joPAsetup type - basic distribution</p><p><strong>Signatures</strong></p><pre><code class="language-none">joPAsetup(wpool::WorkerPool,dims::Dims;
    DT::DataType=joFloat,
    chunks::Vector{Integer}=joPAsetup_etc.default_chunks(dims,sorted(workers(wpool))),
    name::String=&quot;joPAsetup&quot;;
joPAsetup(dims::Dims;kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>wpool</code>: WorkerPool instance - defaults to WorkerPool(workers())</li><li><code>dims</code>: tuple with array&#39;s dimensions</li><li><code>DT</code>: DataType of array&#39;s elements</li><li><code>chunks</code>: vector of number of parts in each dimension</li><li><code>name</code>: name of distributor</li></ul><p><strong>Examples</strong></p><ul><li><code>joPAsetup((3,40,5);DT=Int8)</code>: basic distributor for Int8 array (3,40,5)</li><li><code>joPAsetup((3,40,5);DT=Int8, chunks=[1,nworkers(),1])</code>: basic distributor for Int8 array (3,40,5) forcing distribution in 2nd dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L162-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Tuple{Vararg{INT,N} where N},N} where N}}} where INT&lt;:Integer" href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Tuple{Vararg{INT,N} where N},N} where N}}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joPAsetup(wpool,parts;[name],[DT])
julia&gt; joPAsetup(parts;[name],[DT])</code></pre><p>Creates joPAsetup type with ultimate distribution topology control</p><p><strong>Signature</strong></p><pre><code class="language-none">joPAsetup(wpool::WorkerPool,parts::Tuple{Vararg{Tuple{Vararg{Integer}}}};
    DT::DataType=joFloat,
    procs::Vector{Integer}=workers(),
    name::String=&quot;joPAsetup&quot;)
joPAsetup(parts::Tuple{Vararg{Tuple{Vararg{INT}}}};kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>wpool</code>: WorkerPool instance - defaults to WorkerPool(workers())</li><li><code>parts</code>: tuple of tuples with subarray&#39;s size on each worker</li><li><code>DT</code>: DataType of array&#39;s elements</li><li><code>name</code>: name of distributor</li></ul><p><strong>Examples</strong></p><ul><li><code>joPAsetup(((3,),(10,10,10,10),(5,));DT=Int8)</code>: distribute Int8 array (3,40,5) over 2nd dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L252-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSALinearOperator" href="#JOLI.joSALinearOperator"><code>JOLI.joSALinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joSALinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelLinearOperator.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistribute" href="#JOLI.joSAdistribute"><code>JOLI.joSAdistribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">joSAdistribute is SharedArray toggle type &amp; constructor

!!! Do not use it to create the operators</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelToggleOperator.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer" href="#JOLI.joSAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joSAdistribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joSAdistribute(m [,parts]; [DT])
julia&gt; joSAdistribute(wpool, m [,parts]; [DT])
julia&gt; joSAdistribute(m, nvc [,parts]; [DT])
julia&gt; joSAdistribute(wpool, m, nvc [,parts]; [DT])
julia&gt; joSAdistribute(dst)
julia&gt; joSAdistribute(SA)</code></pre><p>defines operator to distribute serial vector into DistributedArrays&#39; vector</p><p><strong>Signature</strong></p><pre><code class="language-none">joSAdistribute(m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);
    kwargs...) where INT&lt;:Integer
joSAdistribute(wpool::WorkerPool,m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joSAdistribute(m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    kwargs...) where INT&lt;:Integer
joSAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joSAdistribute(dst::joPAsetup;gclean::Bool=false)
joSAdistribute(A::joSAdistributedLinearOperator;gclean::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: length of the vector</li><li><code>nvc</code>: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension</li><li><code>parts</code>: custom partitioning of distributed dimension</li><li><code>wpool</code>: custom WorkerPool</li><li><code>DT</code>: DataType for joPAsetup</li><li><code>dst</code>: joPAsetup</li><li><code>SA</code>: joSAdistributedLinearOperator</li><li><code>glcean</code>: clean SArray after gathering</li></ul><p><strong>Notes</strong></p><ul><li>no type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)</li><li>adjoint/transpose of the joSAdistribute will gather distributed vector into serial vector</li></ul><p><strong>Examples</strong></p><ul><li><code>joSAdistribute(5)</code>: distribute vector of lenght 5 into default WorkerPool</li><li><code>joSAdistribute(5,2)</code>: distribute multi-vector of lenght 5 with 2 columns into default WorkerPool</li><li><code>joSAdistribute(5)&#39;</code>: gather vector of lenght 5</li><li><code>joSAdistribute(5,2)&#39;</code>: gather multi-vector of lenght 5 with 2 columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractSAparallelToggleOperator/constructors.jl#L9-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistributedLinearOperator" href="#JOLI.joSAdistributedLinearOperator"><code>JOLI.joSAdistributedLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joSAdistributedLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelLinearOperator.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistributingLinearOperator" href="#JOLI.joSAdistributingLinearOperator"><code>JOLI.joSAdistributingLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joSAdistributingLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelLinearOperator.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAgather" href="#JOLI.joSAgather"><code>JOLI.joSAgather</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">joSAgather is SharedArray toggle type &amp; constructor

!!! Do not use it to create the operators</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelToggleOperator.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer" href="#JOLI.joSAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joSAgather</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joSAgather(m [,parts]; [DT])
julia&gt; joSAgather(wpool, m [,parts]; [DT])
julia&gt; joSAgather(m, nvc [,parts]; [DT])
julia&gt; joSAgather(wpool, m, nvc [,parts]; [DT])
julia&gt; joSAgather(dst)
julia&gt; joSAgather(SA)</code></pre><p>defines operator to gather DistributedArrays&#39; vector into serial vector</p><p><strong>Signature</strong></p><pre><code class="language-none">joSAgather(m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);
    kwargs...) where INT&lt;:Integer
joSAgather(wpool::WorkerPool,m::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joSAgather(m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    kwargs...) where INT&lt;:Integer
joSAgather(wpool::WorkerPool,m::Integer,nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    DT::DataType=joFloat,gclean::Bool=false) where INT&lt;:Integer
joSAgather(dst::joPAsetup;gclean::Bool=false)
joSAgather(A::joSAdistributedLinearOperator;gclean::Bool=false)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: length of the vector</li><li><code>nvc</code>: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension</li><li><code>parts</code>: custom partitioning of distributed dimension</li><li><code>wpool</code>: custom WorkerPool</li><li><code>DT</code>: DataType for joPAsetup</li><li><code>glcean</code>: clean SArray after gathering</li><li><code>dst</code>: joPAsetup</li><li><code>SA</code>: joSAdistributedLinearOperator</li></ul><p><strong>Notes</strong></p><ul><li>no type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)</li><li>adjoint/transpose of the joSAgather will distribute serial vector into DistributedArrays&#39; vector</li></ul><p><strong>Examples</strong></p><ul><li><code>joSAgather(5)</code>: gather vector of lenght 5</li><li><code>joSAgather(5,2)</code>: gather multi-vector of lenght 5 with 2 columns</li><li><code>joSAgather(5)&#39;</code>: distribute vector of lenght 5 into default WorkerPool</li><li><code>joSAgather(5,2)&#39;</code>: distribute multi-vector of lenght 5 with 2 columns into default WorkerPool</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractSAparallelToggleOperator/constructors.jl#L112-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAgatheringLinearOperator" href="#JOLI.joSAgatheringLinearOperator"><code>JOLI.joSAgatheringLinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>joSAgatheringLinearOperator is glueing type &amp; constructor</p><p>!!! Do not use it to create the operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joTypes/joAbstractSAparallelLinearOperator.jl#L84-L89">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.SPMD.scatter-Tuple{AbstractArray,joPAsetup}" href="#DistributedArrays.SPMD.scatter-Tuple{AbstractArray,joPAsetup}"><code>DistributedArrays.SPMD.scatter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; scatter(A,d)</code></pre><p>Scatters SharedArray according to given joPAsetup.</p><p><strong>Signature</strong></p><pre><code class="language-none">scatter(a::AbstractArray,d::joPAsetup)</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: array to ditribute</li><li><code>d</code>: see help for joPAsetup</li></ul><p><strong>Notes</strong></p><ul><li>the type in joPAsetup is ignored here</li><li>one of the dimensions must be large enough to hold at least one element on each worker</li></ul><p><strong>Examples</strong></p><ul><li><code>scatter(A,d)</code>: scatter A using given distributor</li><li><code>scatter(A,joPAsetup(size(A)...))</code>: scatter A using default distributor settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/SharedArraysSupport.jl#L115-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.dfill-Tuple{Function,joPAsetup}" href="#DistributedArrays.dfill-Tuple{Function,joPAsetup}"><code>DistributedArrays.dfill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dfill(F, d; [DT])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled with elements provided by anonymous function F.</p><p><strong>Signature</strong></p><pre><code class="language-none">dfill(F::Function,d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>F</code>: anonymous function of the form <code>I-&gt;f(...,map(length,I)))</code></li><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Notes</strong></p><ul><li>function F will be passed via <code>map(length,I)</code> the tuple with dimensions of local part</li><li>one has to pass array type manualy to F</li></ul><p><strong>Examples</strong></p><ul><li><code>dfill(I-&gt;ones(d.DT,map(length,I)),d)</code>: fill a distributed array with ones of type d.DT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L111-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.dfill-Tuple{Number,joPAsetup}" href="#DistributedArrays.dfill-Tuple{Number,joPAsetup}"><code>DistributedArrays.dfill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dfill(x, d; [DT])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled with x.</p><p><strong>Signature</strong></p><pre><code class="language-none">dfill(x::Number,d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Examples</strong></p><ul><li><code>dfill(3.,d)</code>: fill a distributed array with d.DT(3.)</li><li><code>dfill(3.,d;DT=Float32)</code>: fill a distributed array with Float32(3.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L142-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.distribute-Tuple{AbstractArray,joPAsetup}" href="#DistributedArrays.distribute-Tuple{AbstractArray,joPAsetup}"><code>DistributedArrays.distribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; distribute(A,d)</code></pre><p>Distributes DArray according to given joPAsetup.</p><p><strong>Signature</strong></p><pre><code class="language-none">distribute(a::AbstractArray,d::joPAsetup)</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: array to ditribute</li><li><code>d</code>: see help for joPAsetup</li></ul><p><strong>Notes</strong></p><ul><li>the type in joPAsetup is ignored here</li><li>distributes over last non-singleton (worker-wise) dimension</li><li>one of the dimensions must be large enough to hold at least one element on each worker</li></ul><p><strong>Examples</strong></p><ul><li><code>distribute(A,d)</code>: distribute A using given distributor</li><li><code>distribute(A,joPAsetup(size(A)...))</code>: distribute A using default distributor settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L323-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.dones-Tuple{joPAsetup}" href="#DistributedArrays.dones-Tuple{joPAsetup}"><code>DistributedArrays.dones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dones(d; [DT])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled with ones.</p><p><strong>Signature</strong></p><pre><code class="language-none">dones(d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Examples</strong></p><ul><li><code>dones(d)</code>: allocate an array of ones</li><li><code>dones(d,DT=Float32)</code>: allocate array of Float32 ones</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L229-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.drand-Tuple{joPAsetup}" href="#DistributedArrays.drand-Tuple{joPAsetup}"><code>DistributedArrays.drand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; drand(d; [DT], [RNG])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled using built-in rand.</p><p><strong>Signature</strong></p><pre><code class="language-none">drand(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li><li><code>RNG</code>: random-number generator function (see help for rand/randn)</li></ul><p><strong>Examples</strong></p><ul><li><code>drand(d)</code>: allocate an array with rand</li><li><code>drand(d,DT=Float32)</code>: allocate array with rand of Float32</li><li><code>drand(d,DT=Float32,RNG=MersenneTwister(1234))</code>: allocate array with rand of Float32 using MersenneTwister() random device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L257-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.drandn-Tuple{joPAsetup}" href="#DistributedArrays.drandn-Tuple{joPAsetup}"><code>DistributedArrays.drandn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; drandn(d; [DT], [RNG])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled using built-in randn.</p><p><strong>Signature</strong></p><pre><code class="language-none">drandn(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li><li><code>RNG</code>: random-number generator function (see help for rand/randn)</li></ul><p><strong>Notes</strong></p><ul><li>only float type are supported by randn (see help for randn)</li></ul><p><strong>Examples</strong></p><ul><li><code>drandn(d)</code>: allocate an array with randn</li><li><code>drandn(d,DT=Float32)</code>: allocate array with randn of Float32</li><li><code>drandn(d,DT=Float32,RNG=MersenneTwister(1234))</code>: allocate array with randn of Float32 using MersenneTwister() random device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L287-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedArrays.dzeros-Tuple{joPAsetup}" href="#DistributedArrays.dzeros-Tuple{joPAsetup}"><code>DistributedArrays.dzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dzeros(d; [DT])</code></pre><p>Constructs a DistributedArrays.DArray, according to given distributor, filled with zeros.</p><p><strong>Signature</strong></p><pre><code class="language-none">dzeros(d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Examples</strong></p><ul><li><code>dzeros(d)</code>: allocate an array of zeros</li><li><code>dzeros(d,DT=Float32)</code>: allocate array of Float32 zeros</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L201-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.dalloc-Tuple{Tuple{Vararg{Int64,N}} where N,Vararg{Any,N} where N}" href="#JOLI.dalloc-Tuple{Tuple{Vararg{Int64,N}} where N,Vararg{Any,N} where N}"><code>JOLI.dalloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dalloc(dims, [...])</code></pre><p>Allocates a DistributedArrays.DArray without value assigment.</p><p>Use it to allocate quicker the array that will have all elements overwritten.</p><p><strong>Signature</strong></p><pre><code class="language-none">dalloc(dims::Dims, [...])</code></pre><p><strong>Arguments</strong></p><ul><li>optional trailing arguments are the same as those accepted by <code>DArray</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L88-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.dalloc-Tuple{joPAsetup}" href="#JOLI.dalloc-Tuple{joPAsetup}"><code>JOLI.dalloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dalloc(d; [DT])</code></pre><p>Allocates a DistributedArrays.DArray, according to given distributor, without value assigment.</p><p>Use it to allocate quicker the array that will have all elements overwritten.</p><p><strong>Signature</strong></p><pre><code class="language-none">dalloc(d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Examples</strong></p><ul><li><code>dalloc(d)</code>: allocate an array</li><li><code>dalloc(d,DT=Float32)</code>: allocate array and overwite d.DT with Float32</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L170-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.dcopy-Union{Tuple{T}, Tuple{LinearAlgebra.Transpose{T,#s26} where #s26&lt;:(DistributedArrays.DArray{T,2,A} where A),joPAsetup}} where T" href="#JOLI.dcopy-Union{Tuple{T}, Tuple{LinearAlgebra.Transpose{T,#s26} where #s26&lt;:(DistributedArrays.DArray{T,2,A} where A),joPAsetup}} where T"><code>JOLI.dcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dcopy(dtr,[dst])</code></pre><p>copy transpose(DArray) into a new DArray using predefined joPAsetup</p><p><strong>Signature</strong></p><pre><code class="language-none">dcopy(Dtr::Transpose{T,&lt;:DArray{T,2}},dst::joPAsetup)
dcopy(Dtr::Transpose{T,&lt;:DArray{T,2}})</code></pre><p><strong>Arguments</strong></p><ul><li><code>dtr</code>: transpose(DArray)</li><li><code>dst</code>: target joPAsetup</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.dparts-Union{Tuple{DistributedArrays.DArray{T,N,A} where A}, Tuple{N}, Tuple{T}} where N where T" href="#JOLI.dparts-Union{Tuple{DistributedArrays.DArray{T,N,A} where A}, Tuple{N}, Tuple{T}} where N where T"><code>JOLI.dparts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; dparts(da)</code></pre><p>return partitioning vector of DArray if partioned in single dimension</p><p><strong>Signature</strong></p><pre><code class="language-none">dparts(da::DArray{T,N})</code></pre><p><strong>Arguments</strong></p><ul><li><code>da</code>: DArray</li></ul><p><strong>Notes</strong></p><ul><li>if DArray is quasi-distributed (over single worker), dparts returns size(da,N)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/DistributedArraysSupport.jl#L25-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joAddSolverAll-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function,Function,Function,Function}} where RDT where DDT" href="#JOLI.joAddSolverAll-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function,Function,Function,Function}} where RDT where DDT"><code>JOLI.joAddSolverAll</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joAddSolver outer constructor</p><pre><code class="language-none">joAddSolverAll(A::joAbstractLinearOperator{DDT,RDT},
    solver::Function,solver_T::Function,solver_A::Function,solver_C::Function)</code></pre><p>Create joLinearOperator with added specific solver(s) for (jo,[m]vec), distinct for each form of the operator.</p><p><strong>Examples</strong></p><pre><code class="language-none">O=joAddSolverAll(O,
    (s,x)-&gt;my_solver(s,x),
    (s,x)-&gt;my_solver_T(s,x),
    (s,x)-&gt;my_solver_A(s,x),
    (s,x)-&gt;my_solver_C(s,x))

O=joAddSolverAll(O,
    (s,x)-&gt;my_solver(s,x),
    @joNF,
    (s,x)-&gt;my_solver_A(s,x),
    @joNF)

O=joAddSolverAll(O,
    (s,x)-&gt;my_solver(s,x),
    @joNF,
    @joNF,
    @joNF)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L257-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joAddSolverAny-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function}} where RDT where DDT" href="#JOLI.joAddSolverAny-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function}} where RDT where DDT"><code>JOLI.joAddSolverAny</code></a> — <span class="docstring-category">Method</span></header><section><div><p>joAddSolver outer constructor</p><pre><code class="language-none">joAddSolverAny(A::joAbstractLinearOperator{DDT,RDT},solver::Function)</code></pre><p>Create joLinearOperator with added solver for (jo,[m]vec), same for each form of the operator</p><p><strong>Example (for all forms of O)</strong></p><pre><code class="language-none">O=joAddSolverAny(O,(s,x)-&gt;my_solver(s,x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L232-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joBlock-Union{Tuple{WDT}, Tuple{RVDT}, Tuple{Array{RVDT,1},Vararg{joAbstractLinearOperator,N} where N}} where WDT&lt;:Number where RVDT&lt;:Integer" href="#JOLI.joBlock-Union{Tuple{WDT}, Tuple{RVDT}, Tuple{Array{RVDT,1},Vararg{joAbstractLinearOperator,N} where N}} where WDT&lt;:Number where RVDT&lt;:Integer"><code>JOLI.joBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joBlock(rows,op1[,op2][,...];[weights=...,][name=...])</code></pre><p>Block operator composed from different square JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joBlock(rows::Vector{RVDT},ops::joAbstractLinearOperator...;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joBlock&quot;)
        where {RVDT&lt;:Integer,WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>rows</code>: # number of operator in a blocks&#39; row</li><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>operators are to be given in row-major order</li><li>all operators in a blocs&#39; row must have the same # of rows (M)</li><li>sum of Ns for operators in each row must be the same</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joBlock are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)
b=rand(ComplexF64,4,8);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)
c=rand(ComplexF64,6,6);
C=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=&quot;C&quot;)
d=rand(ComplexF64,6,6);
D=joMatrix(d;DDT=ComplexF32,RDT=ComplexF64,name=&quot;D&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,4)</code></pre><p>basic blocks in function syntax</p><pre><code class="language-none">S=joBlock([2,2],A,B,C,D)</code></pre><p>basic blocks in [] syntax</p><pre><code class="language-none">S=[A B; C D]</code></pre><p>weighted blocks</p><pre><code class="language-none">S=joBlock([2,2],A,B,C,D;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joBlock.jl#L14-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joBlockDiag-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number" href="#JOLI.joBlockDiag-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joBlockDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joBlockDiag(op1[,op2][,...];[weights=...,][name=...])</code></pre><p>Block-diagonal operator composed from different square JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joBlockDiag(ops::joAbstractLinearOperator...;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joBlockDiag&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all operators must be square (M(i)==N(i))</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joBlockDiag are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)
b=rand(ComplexF64,8,8);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)
c=rand(ComplexF64,6,6);
C=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=&quot;C&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic block diagonal</p><pre><code class="language-none">BD=joBlockDiag(A,B,C)</code></pre><p>weighted block diagonal</p><pre><code class="language-none">BD=joBlockDiag(A,B,C;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joBlockDiag.jl#L14-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joBlockDiag-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number" href="#JOLI.joBlockDiag-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joBlockDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joBlockDiag(l,op;[weights=...,][name=...])</code></pre><p>Block-diagonal operator composed from l-times replicated square JOLI operator</p><p><strong>Signature</strong></p><pre><code class="language-none">joBlockDiag(l::Integer,op::joAbstractLinearOperator;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joBlockDiag&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>l</code>: # of replcated blocks</li><li><code>op</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all given operators must have same domain/range types</li><li>the domain/range types of joBlockDiag are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operator</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic block diagonal</p><pre><code class="language-none">BD=joBlockDiag(3,A)</code></pre><p>weighted block diagonal</p><pre><code class="language-none">BD=joBlockDiag(3,A;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joBlockDiag.jl#L109-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joConj-Tuple{Integer}" href="#JOLI.joConj-Tuple{Integer}"><code>JOLI.joConj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joConj(m;[VDP=...,][name=...])</code></pre><p>Takes conjugate of vector (experimantal).</p><p><strong>Signature</strong></p><pre><code class="language-none">joConj(m::Integer;VDP::DataType=joFloat,name::String=&quot;joConj&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: vector size</li><li>keywords<ul><li><code>VDP</code>: float element type of Complex number in vector</li><li><code>name</code>: custom name</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joVecConvert.jl#L58-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joConstants-Union{Tuple{EDT}, Tuple{Integer,EDT}} where EDT&lt;:Number" href="#JOLI.joConstants-Union{Tuple{EDT}, Tuple{Integer,EDT}} where EDT&lt;:Number"><code>JOLI.joConstants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joConstants(m,a;[DDT=...,][RDT=...,][name=...])
julia&gt; op = joConstants(m,n,a;[DDT=...,][RDT=...,][name=...])</code></pre><p>Operator equivalent to matrix of same elements</p><p><strong>Signature</strong></p><pre><code class="language-none">joConstants(m::Integer,a::EDT;
    DDT::DataType=EDT,RDT::DataType=promote_type(EDT,DDT),
    name::String=&quot;joConstants&quot;) where {EDT&lt;:Number}
joConstants(m::Integer,n::Integer,a::EDT;
    DDT::DataType=EDT,RDT::DataType=promote_type(EDT,DDT),
    name::String=&quot;joConstants&quot;) where {EDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: size</li><li><code>a</code>: element value, default DDT/RDT will have the same type as <code>a</code></li><li>optional<ul><li><code>n</code>: 2nd dimension if not square</li></ul></li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joConstants(m,a)
joConstants(m,n,a)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joConstants(m,a; DDT=Float32)
joConstants(m,a; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joConstants.jl#L4-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joConvert-Tuple{Integer,DataType,DataType}" href="#JOLI.joConvert-Tuple{Integer,DataType,DataType}"><code>JOLI.joConvert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joConvert(m,DDT,RDT;[name=...])</code></pre><p>Converts vector between different types (experimental)</p><p><strong>Signature</strong></p><pre><code class="language-none">joConvert(m::Integer,DDT::DataType,RDT::DataType;name::String=&quot;joConvert&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: vector size</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li>keywords<ul><li><code>name</code>: custom name</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joVecConvert.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joCurvelet2D-Tuple{Integer,Integer}" href="#JOLI.joCurvelet2D-Tuple{Integer,Integer}"><code>JOLI.joCurvelet2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joCurvelet2D(n1,n2;[DDT=joFloat,][RDT=DDT,]
                [nbscales=...,][nbangles_coarse=...,][all_crvlts=...,]
                [real_crvlts=...,][zero_finest=...,][name=...])</code></pre><p>2D Curvelet transform (wrapping) over fast dimensions</p><p><strong>Signature</strong></p><pre><code class="language-none">function joCurvelet2D(n1::Integer,n2::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,
        nbscales::Integer=0,
        nbangles_coarse::Integer=16,
        all_crvlts::Bool=false,
        real_crvlts::Bool=true,
        zero_finest::Bool=false,
        name::String=&quot;joCurvelt2D&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>n1</code>,<code>n2</code>: image sizes</li><li>keywords<ul><li><code>nbscales</code>: # of scales (requires #&gt;=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))</li><li><code>nbangles_coarse</code>: # of angles at coarse scale (requires #%4==0, #&gt;=8; defaults to 16)</li><li><code>all_crvlts</code>: curvelets at finnest scales (defaults to false)</li><li><code>real_crvlts</code>: real transform (defaults to true) and requires real input</li><li><code>zero_finest</code>: zero out finnest scales (defaults to false)</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>if DDT:&lt;Real for complex transform then imaginary part will be neglected for transpose/adjoint</li><li>isadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.</li></ul><p><strong>Examples</strong></p><p>real transform (64-bit)</p><pre><code class="language-none">joCurvelet2D(32,32)</code></pre><p>complex transform (64-bit)</p><pre><code class="language-none">joCurvelet2D(32,32;real_crvlts=false)</code></pre><p>real transform with curevelts at the finnest scales (64-bit)</p><pre><code class="language-none">joCurvelet2D(32,32;all_crvlts=true)</code></pre><p>real transform with zeros at the finnest scales (64-bit)</p><pre><code class="language-none">joCurvelet2D(32,32;zero_finest=true)</code></pre><p>complex transform with real 64-bit input for forward</p><pre><code class="language-none">joCurvelet2D(32,32;DDT=Float64,real_crvlts=false)</code></pre><p>complex transform with just precision specification for curvelets</p><pre><code class="language-none">joCurvelet2D(32,32;DDT=Float32,RDT=Float64,real_crvlts=false)</code></pre><p>complex transform with full type specification for curvelets (same as above)</p><pre><code class="language-none">joCurvelet2D(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joCurvelet2D.jl#L48-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joCurvelet2DnoFFT-Tuple{Integer,Integer}" href="#JOLI.joCurvelet2DnoFFT-Tuple{Integer,Integer}"><code>JOLI.joCurvelet2DnoFFT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joCurvelet2DnoFFT(n1,n2;[DDT=joComplex,][RDT=DDT,]
                [nbscales=...,][nbangles_coarse=...,][all_crvlts=...,]
                [real_crvlts=...,][zero_finest=...,][name=...])</code></pre><p>2D Curvelet transform (wrapping) over fast dimensions without FFT</p><p><strong>Signature</strong></p><pre><code class="language-none">function joCurvelet2DnoFFT(n1::Integer,n2::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,
        nbscales::Integer=0,
        nbangles_coarse::Integer=16,
        all_crvlts::Bool=false,
        real_crvlts::Bool=true,
        zero_finest::Bool=false,
        name::String=&quot;joCurvelt2DnoFFT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>n1</code>,<code>n2</code>: image sizes</li><li>keywords<ul><li><code>nbscales</code>: # of scales (requires #&gt;=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))</li><li><code>nbangles_coarse</code>: # of angles at coarse scale (requires #%4==0, #&gt;=8; defaults to 16)</li><li><code>all_crvlts</code>: curvelets at finnest scales (defaults to false)</li><li><code>real_crvlts</code>: real transform (defaults to true) and requires real input</li><li><code>zero_finest</code>: zero out finnest scales (defaults to false)</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>real joCurvelet2DnoFFT passed adjoint test while either combined with joDFT, or with isadjont flag userange=true</li><li>isadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.</li></ul><p><strong>Examples</strong></p><p>real transform (64-bit)</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32)</code></pre><p>complex transform (64-bit)</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;real_crvlts=false)</code></pre><p>real transform with curevelts at the finnest scales (64-bit)</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;all_crvlts=true)</code></pre><p>real transform with zeros at the finnest scales (64-bit)</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;zero_finest=true)</code></pre><p>complex transform with complex 64-bit input for forward</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;DDT=Float64,real_crvlts=false)</code></pre><p>complex transform with just precision specification for curvelets</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;DDT=Float32,RDT=Float64,real_crvlts=false)</code></pre><p>complex transform with full type specification for curvelets (same as above)</p><pre><code class="language-none">joCurvelet2DnoFFT(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joCurvelet2DnoFFT.jl#L49-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number" href="#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joDAdistributedLinOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joDAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])</code></pre><p>Create a linear operator working on 2D DArray in multi-vector (over 2nd dimension) mode.</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    fclean::Bool=false,rclean::Bool=false) where {DDT&lt;:Number,RDT&lt;:Number,INT&lt;:Integer}
joDAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    fclean::Bool=false,rclean::Bool=false) where {ADDT&lt;:Number,ARDT&lt;:Number,INT&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: joAbstractLinearOperator type</li><li><code>nvc</code>: number of columns in multi-vector</li><li><code>parts</code>: custom partitioning of 2nd diemnsion </li><li><code>fclean</code>: close DArray after forward operation</li><li><code>rclean</code>: close DArray after forward operation in transpose/adjoint mode</li></ul><p><strong>Examples</strong></p><ul><li><code>joDAdistributedLinOp(A,30)</code>: operator that will apply A to distributed multivector with 30 columns</li></ul><p><strong>Notes</strong></p><ul><li>nvc must be &gt;= then # of workers in the WorkerPool</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractDAparallelLinearOperator/constructors.jl#L56-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number" href="#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joDAdistributedLinOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joDAdistributedLinOp(A,psin; [,fclean] [,rclean])</code></pre><p>Create a linear operator working on 2D DArray in multi-vector (over 2nd dimension) mode.</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDAdistributedLinOp(A::joAbstractLinearOperator{DDT,RDT},psin::joPAsetup,
    fclean::Bool=false,rclean::Bool=false) where {DDT&lt;:Number,RDT&lt;:Number,INT&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: joAbstractLinearOperator type</li><li><code>psin</code>: parallel setup from jpPAsetup</li><li><code>fclean</code>: close DArray after forward operation</li><li><code>rclean</code>: close DArray after forward operation in transpose/adjoint mode</li></ul><p><strong>Examples</strong></p><ul><li><code>ps=joPAsetup((12,30))</code>: define parallel setup for operator with 12 columns and multi-vector with 30 columns</li><li><code>joDAdistributedLinOp(A,ps)</code>: operator that will apply A to distributed multi-vector with 30 columns</li></ul><p><strong>Notes</strong></p><ul><li>nvc of joPAsetup must be &gt;= then # of workers in the WorkerPool</li><li>DT in joPAsetup will be overwritten by DDT of the operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractDAparallelLinearOperator/constructors.jl#L9-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDCT-Tuple{Vararg{Integer,N} where N}" href="#JOLI.joDCT-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joDCT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDCT(m[,n[,...]];[planned::Bool=true][,DDT=joFloat][,RDT=DDT])</code></pre><p>Multi-dimensional DCT transform over fast dimension(s)</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDCT(ms::Integer...;
    planned::Bool=true,
    DDT::DataType=joFloat,RDT::DataType=DDT,
    name::String=&quot;joDCT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: dimension</li><li>optional<ul><li><code>n,...</code>: more dimensions</li></ul></li><li>keywords<ul><li><code>planned</code>: use DCT plan</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>multidimensional image must be vectorized</li><li>if you intend to use joDCT in remote* calls, you have to either set planned=false or create the operator on the worker</li><li>joDCT is always planned if applied to multi-vector</li></ul><p><strong>Examples</strong></p><p>1D DCT</p><pre><code class="language-none">joDCT(m)</code></pre><p>1D DCT without the precomputed plan</p><pre><code class="language-none">joDCT(m; planned=false)</code></pre><p>2D DCT</p><pre><code class="language-none">joDCT(m,n)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joDCT(m; DDT=Float32)
joDCT(m; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joDCT.jl#L85-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDFT-Tuple{Vararg{Integer,N} where N}" href="#JOLI.joDFT-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joDFT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDFT(m[,n[,...]];[plannned=...,][centered=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>Multi-dimensional FFT transform over fast dimension(s)</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDFT(ms::Integer...;
    planned::Bool=true, centered::Bool=false,
    DDT::DataType=joFloat, RDT::DataType=(DDT&lt;:Real ? Complex{DDT} : DDT),
    name::String=&quot;joDFT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: dimension</li><li>optional<ul><li><code>n,...</code>: more dimensions</li></ul></li><li>keywords<ul><li><code>planned</code>: use FFTW plan</li><li><code>centered</code>: produce centered coefficients</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>multidimensional image must be vectorized</li><li>if DDT:&lt;Real then imaginary part will be neglected for transpose/adjoint</li><li>if you intend to use joDFT in remote* calls, you have to either set planned=false or create the operator on the worker</li><li>joDFT is always planned if applied to multi-vector</li></ul><p><strong>Examples</strong></p><p>1D FFT</p><pre><code class="language-none">joDFT(m)</code></pre><p>1D FFT with centered coefficients</p><pre><code class="language-none">joDFT(m; centered=true)</code></pre><p>1D FFT without the precomputed plan</p><pre><code class="language-none">joDFT(m; planned=false)</code></pre><p>2D FFT</p><pre><code class="language-none">joDFT(m,n)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joDFT(m; DDT=Float32)
joDFT(m; DDT=Float32,RDT=ComplexF64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joDFT.jl#L106-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDWT" href="#JOLI.joDWT"><code>JOLI.joDWT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDWT(m,[n,][wt];[L=...,][DDT=...,][RDT=...])</code></pre><p>1/2-dimensional DWT transform over fast dimension(s) - based on Wavelets.jl. See Wavelets.jl package form more information, especially current filter list.</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDWT(m::Integer,n::Integer,wt::OrthoFilter=wavelet(WT.haar);
    L::Integer=maxtransformlevels(min(m,n)),
    DDT::DataType=joFloat,RDT::DataType=DDT,
    name::String=&quot;joDWT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: dimention</li><li>optional<ul><li><code>n</code>: 2nd dimention</li><li><code>wt</code>: wavelet filter (Haar by default)</li></ul></li><li>keywords<ul><li><code>L</code>: number of levels</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>only square 2D arrays are supported for now due to limitations of Wavelets.jl package</li></ul><p><strong>Examples</strong></p><p>1D DWT with default wavelet (Haar wavelet)</p><pre><code class="language-none">joDWT(m)</code></pre><p>define wavelet</p><pre><code class="language-none">wt=wavelet(WT.haar)</code></pre><p>1D DWT</p><pre><code class="language-none">joDWT(m,wt)</code></pre><p>2D DWT</p><pre><code class="language-none">joDWT(m,n,wt)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joDWT(m,wt; DDT=Float32)
joDWT(m,wt; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joDWT.jl#L37-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDiag-Union{Tuple{Union{Array{EDT,1}, SubArray{EDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{EDT,Ti,1} where Ti} where dA&lt;:(Array{EDT,N} where N)}, Tuple{EDT}} where EDT" href="#JOLI.joDiag-Union{Tuple{Union{Array{EDT,1}, SubArray{EDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{EDT,Ti,1} where Ti} where dA&lt;:(Array{EDT,N} where N)}, Tuple{EDT}} where EDT"><code>JOLI.joDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDiag(v;[makecopy=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>Diagonal matrix with elements from given vector</p><p><strong>Signature</strong></p><pre><code class="language-none">function joDiag(v::LocalVector{EDT};makecopy::Bool=true,
    DDT::DataType=EDT,RDT::DataType=promote_type(EDT,DDT),name::String=&quot;joDiag&quot;) where {EDT}</code></pre><p><strong>Arguments</strong></p><ul><li><code>v</code>: vector of diagonal elements</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joDiag(rand(m))</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joDiag(rand(m); DDT=Float32)
joDiag(rand(m); DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joDiag.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDict-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number" href="#JOLI.joDict-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDict(op1[,op2][,...];[weights=...,][name=...])</code></pre><p>Dictionary (single block row) operator composed from different JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joDict(ops::joAbstractLinearOperator...;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joDict&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all operators must have the same # of rows (M)</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joDict are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)
b=rand(ComplexF64,4,8);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)
c=rand(ComplexF64,4,6);
C=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=&quot;C&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic dictionary in function syntax</p><pre><code class="language-none">D=joDict(A,B,C)</code></pre><p>basic dictionary in [] syntax</p><pre><code class="language-none">D=[A B C]</code></pre><p>weighted dictionary</p><pre><code class="language-none">D=joDict(A,B,C;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joDict.jl#L14-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDict-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number" href="#JOLI.joDict-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joDict(l,op;[weights=...,][name=...])</code></pre><p>Dictionary operator composed from l-times replicated square JOLI operator</p><p><strong>Signature</strong></p><pre><code class="language-none">joDict(l::Integer,op::joAbstractLinearOperator;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joDict&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>l</code>: # of replcated blocks</li><li><code>op</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all operators must have the same # of rows (M)</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joDict are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic dictionary</p><pre><code class="language-none">D=joDict(3,A)</code></pre><p>weighted dictionary</p><pre><code class="language-none">D=joDict(3,A;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joDict.jl#L112-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joDirac-Tuple{Integer}" href="#JOLI.joDirac-Tuple{Integer}"><code>JOLI.joDirac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">joDirac(m;[DDT=...,][RDT=...,][name=...])</code></pre><p>Dirac operator</p><p><strong>Signature</strong></p><pre><code class="language-none">joDirac(m::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joDirac&quot;)</code></pre><p><strong>Arguments</strong></p><p><strong>Arguments</strong></p><ul><li><code>m</code>: size</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">A=joDirac(3)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joDirac(3; DDT=Float32)
A=joDirac(3; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joDirac.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joExtend-Tuple{Integer,Symbol}" href="#JOLI.joExtend-Tuple{Integer,Symbol}"><code>JOLI.joExtend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joExtend(n,pad_type;[pad_lower=...,][pad_upper=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>1D extension operator</p><p><strong>Signature</strong></p><pre><code class="language-none">function joExtend(n::Integer,pad_type::Symbol;
    pad_upper::Integer=0,pad_lower::Integer=0,
    DDT::DataType=joFloat,RDT::DataType=DDT,
    name=&quot;joExtend&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>n</code> : size of input vector</li><li><code>pad_type</code> : one of the symbols<ul><li><code>:zeros</code> : pad signal with zeros</li><li><code>:border</code> : pad signal with values at the edge of the domain</li><li><code>:mirror</code> : mirror extension of the signal</li><li><code>:periodic</code> : periodic extension of the signal</li></ul></li><li>keywords<ul><li><code>pad_lower</code> : number of points to pad on the lower index end</li><li><code>pad_upper</code> : number of points to pad on the upper index end</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><p>extend a n-length vector with 10 zeros on either side</p><pre><code class="language-none">joExtend(n,:zeros; pad_lower=10,pad_upper=10)</code></pre><p>append, to a n-length vector, so that x[n+1:n+10] = x[n]</p><pre><code class="language-none">joExtend(n,:border; pad_upper=10)</code></pre><p>prepend, to n-length vector, its mirror extension: y=[reverse(x[1:10]);x]</p><pre><code class="language-none">joExtend(n,:mirror; pad_lower=10)</code></pre><p>append, to n-length vector, its periodic extension: y=[x;x[1:10]]</p><pre><code class="language-none">joExtend(n,:periodic; pad_upper=10)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joExtend(n,:mirror; pad_lower=10,DDT=Float32)
joExtend(n,:periodic; pad_upper=10,DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joExtend.jl#L90-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joEye-Tuple{Integer,Integer}" href="#JOLI.joEye-Tuple{Integer,Integer}"><code>JOLI.joEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joEye(m,n;[DDT=...,][RDT=...,][name=...])</code></pre><p>Identity matrix - rectangular</p><p><strong>Signature</strong></p><pre><code class="language-none">joEye(m::Integer,n::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joEye&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m,n</code>: sizes</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joEye(m,n)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joEye(m,n; DDT=Float32)
joEye(m,n; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joEye.jl#L42-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joEye-Tuple{Integer}" href="#JOLI.joEye-Tuple{Integer}"><code>JOLI.joEye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joEye(m;[DDT=...,][RDT=...,][name=...])</code></pre><p>Identity matrix - square</p><p><strong>Signature</strong></p><pre><code class="language-none">joEye(m::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joEye&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: sizes</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joEye(m)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joEye(m; DDT=Float32)
joEye(m; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joEye.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joGaussian" href="#JOLI.joGaussian"><code>JOLI.joGaussian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joGaussian(M,[N];
            [implicit=...,][normalized=...,][orthonormal=...,][RNG=...,]
            [DDT=...,][RDT=...,][name=...])</code></pre><p>Gausian matrix</p><p><strong>Signature</strong></p><pre><code class="language-none">joGaussian(M::Integer,N::Integer=M;
    implicit::Bool=false,normalized::Bool=false,orthonormal::Bool=false,
    RNG::AbstractRNG=Random.seed!(),
    DDT::DataType=joFloat,RDT::DataType=DDT,
    name::String=&quot;joGaussian&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>M[,N]</code>: sizes</li><li>keywords<ul><li><code>implicit</code>: keyword element-free operator if true</li><li><code>normalized</code>: keyword normalized (unit global-norm for explicit or unit-column norm for implicit) operator if true</li><li><code>orthonormal</code>: keyword explict orthonormal operator if true (above implicit/normalized is ignorred); requires M&lt;=N</li><li><code>RNG</code>: keyword random number generator function with explicit seeding</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>AbstractRNG has to support seeding (RNG.seed atribute to type); e.g. RandomDevice() will not work</li></ul><p><strong>Examples</strong></p><p>not-normalized and explict dense matrix</p><pre><code class="language-none">A=joGaussian(M,N)</code></pre><p>explicit orthonormal dense matrix</p><pre><code class="language-none">A=joGaussian(M,orthonormal=true)</code></pre><p>not-normalized and element-free operator</p><pre><code class="language-none">A=joGaussian(M,implicit=true)</code></pre><p>normalized and explict dense matrix</p><pre><code class="language-none">A=joGaussian(M,normalized=true)</code></pre><p>normalized and element-free operator</p><pre><code class="language-none">A=joGaussian(M,implicit=true,normalized=true)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joGaussian(M,N; DDT=Float32)
A=joGaussian(M,N; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMixedConstructors/joGaussian.jl#L64-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joImag-Tuple{Integer}" href="#JOLI.joImag-Tuple{Integer}"><code>JOLI.joImag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joImag(m;[VDP=...,][name=...])</code></pre><p>Takes imag part of vector (experimantal).</p><p>transpose/adjont puts the real vector into imag part of the complex vector with zero real part</p><p><strong>Signature</strong></p><pre><code class="language-none">joReal(m::Integer;VDP::DataType=joFloat,name::String=&quot;joImag&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: vector size</li><li>keywords<ul><li><code>VDP</code>: float element type of Complex number in vector</li><li><code>name</code>: custom name</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joVecConvert.jl#L31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinInterp1D-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T&lt;:AbstractFloat" href="#JOLI.joLinInterp1D-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T&lt;:AbstractFloat"><code>JOLI.joLinInterp1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joLinInterp1D(xin,xout;[DDT=...,][RDT=...,][name=...])</code></pre><p>1D Linear interpolation operator</p><p><strong>Signature</strong></p><pre><code class="language-none">function joLinInterp1D(xin::AbstractArray{T,1},xout::AbstractArray{T,1};
    DDT::DataType=T,RDT::DataType=DDT,name::String=&quot;joLinInterp1D&quot;) where {T&lt;:AbstractFloat}</code></pre><p><strong>Arguments</strong></p><ul><li><code>xin</code>  - input grid</li><li><code>xout</code> - output grid</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The interval [minimum(xout),maximum(xout)] must be contained in the interval [minimum(xin),maximum(xin)]</li></ul><p><strong>Examples</strong></p><p>% description</p><pre><code class="language-none">joLinInterp1D(xin,xout)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joLinInterp1D(xin,xout; DDT=Float32)
joLinInterp1D(xin,xout; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joLinInterp1D.jl#L49-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionAll" href="#JOLI.joLinearFunctionAll"><code>JOLI.joLinearFunctionAll</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunctionAll(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLinearFunctionAll&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionFwd" href="#JOLI.joLinearFunctionFwd"><code>JOLI.joLinearFunctionFwd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunctionFwd(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLinearFunctionFwd&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L144-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionFwd_A" href="#JOLI.joLinearFunctionFwd_A"><code>JOLI.joLinearFunctionFwd_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunctionFwd_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLinearFunctionFwd_A&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L196-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionFwd_T" href="#JOLI.joLinearFunctionFwd_T"><code>JOLI.joLinearFunctionFwd_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunctionFwd_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLinearFunctionFwd_T&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplaceAll" href="#JOLI.joLinearFunctionInplaceAll"><code>JOLI.joLinearFunctionInplaceAll</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplaceAll(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplaceAll&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplaceFwd" href="#JOLI.joLinearFunctionInplaceFwd"><code>JOLI.joLinearFunctionInplaceFwd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplaceFwd(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplaceAll&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplaceFwd_A" href="#JOLI.joLinearFunctionInplaceFwd_A"><code>JOLI.joLinearFunctionInplaceFwd_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplaceFwd_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplaceFwd_A&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L208-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplaceFwd_T" href="#JOLI.joLinearFunctionInplaceFwd_T"><code>JOLI.joLinearFunctionInplaceFwd_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplaceFwd_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplaceFwd_T&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplace_A" href="#JOLI.joLinearFunctionInplace_A"><code>JOLI.joLinearFunctionInplace_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplace_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function, iop::Function,iop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplace_A&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunctionInplace_T" href="#JOLI.joLinearFunctionInplace_T"><code>JOLI.joLinearFunctionInplace_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLinearFunctionInplace_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function, iop::Function,iop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLinearFunctionInplace_T&quot;)</code></pre><p>Look up argument names in help to joLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L120-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunction_A" href="#JOLI.joLinearFunction_A"><code>JOLI.joLinearFunction_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunction_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function, iop::Function,iop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLinearFunction_A&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L112-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLinearFunction_T" href="#JOLI.joLinearFunction_T"><code>JOLI.joLinearFunction_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLinearFunction outer constructor</p><pre><code class="language-none">joLinearFunction_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function, iop::Function,iop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLinearFunction_T&quot;)</code></pre><p>Look up argument names in help to joLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperator/constructors.jl#L80-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionAll" href="#JOLI.joLooseLinearFunctionAll"><code>JOLI.joLooseLinearFunctionAll</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunctionAll(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLooseLinearFunctionAll&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L68-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionFwd" href="#JOLI.joLooseLinearFunctionFwd"><code>JOLI.joLooseLinearFunctionFwd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunctionFwd(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLooseLinearFunctionAll&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L158-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionFwd_A" href="#JOLI.joLooseLinearFunctionFwd_A"><code>JOLI.joLooseLinearFunctionFwd_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunctionFwd_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLooseLinearFunctionFwd_A&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L210-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionFwd_T" href="#JOLI.joLooseLinearFunctionFwd_T"><code>JOLI.joLooseLinearFunctionFwd_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunctionFwd_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,
    name::String=&quot;joLooseLinearFunctionFwd_T&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L182-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplaceAll" href="#JOLI.joLooseLinearFunctionInplaceAll"><code>JOLI.joLooseLinearFunctionInplaceAll</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplaceAll(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplaceAll&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L238-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplaceFwd" href="#JOLI.joLooseLinearFunctionInplaceFwd"><code>JOLI.joLooseLinearFunctionInplaceFwd</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplaceFwd(m::Integer,n::Integer,
    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplaceAll&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L306-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplaceFwd_A" href="#JOLI.joLooseLinearFunctionInplaceFwd_A"><code>JOLI.joLooseLinearFunctionInplaceFwd_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplaceFwd_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplaceFwd_A&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L350-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplaceFwd_T" href="#JOLI.joLooseLinearFunctionInplaceFwd_T"><code>JOLI.joLooseLinearFunctionInplaceFwd_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplaceFwd_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplaceFwd_T&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L328-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplace_A" href="#JOLI.joLooseLinearFunctionInplace_A"><code>JOLI.joLooseLinearFunctionInplace_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplace_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function, iop::Function,iop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplace_A&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L284-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunctionInplace_T" href="#JOLI.joLooseLinearFunctionInplace_T"><code>JOLI.joLooseLinearFunctionInplace_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunctionInplace outer constructor</p><pre><code class="language-none">joLooseLinearFunctionInplace_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function, iop::Function,iop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    name::String=&quot;joLooseLinearFunctionInplace_T&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunctionInplace type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions provide correct DDT &amp; RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractLinearOperatorInplace/constructors.jl#L262-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunction_A" href="#JOLI.joLooseLinearFunction_A"><code>JOLI.joLooseLinearFunction_A</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunction_A(m::Integer,n::Integer,
    fop::Function,fop_A::Function, iop::Function,iop_A::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLooseLinearFunction_A&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joLooseLinearFunction_T" href="#JOLI.joLooseLinearFunction_T"><code>JOLI.joLooseLinearFunction_T</code></a> — <span class="docstring-category">Function</span></header><section><div><p>joLooseLinearFunction outer constructor</p><pre><code class="language-none">joLooseLinearFunction_T(m::Integer,n::Integer,
    fop::Function,fop_T::Function, iop::Function,iop_T::Function,
    DDT::DataType,RDT::DataType=DDT;
    fMVok::Bool=false,iMVok::Bool=false,
    name::String=&quot;joLooseLinearFunction_T&quot;)</code></pre><p>Look up argument names in help to joLooseLinearFunction type.</p><p><strong>Notes</strong></p><ul><li>the developer is responsible for ensuring that used functions take/return correct DDT/RDT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractFosterLinearOperator/constructors.jl#L94-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMask-Tuple{BitArray{1}}" href="#JOLI.joMask-Tuple{BitArray{1}}"><code>JOLI.joMask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joMask(mask;[makecopy=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>Mask operator with BitArray mask</p><p><strong>Signature</strong></p><pre><code class="language-none">function joMask(mask::BitArray{1};
    makecopy::Bool=true,DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joMask&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>mask</code>: BitArray mask of true indecies</li><li>keywords<ul><li><code>makecopy</code>: copy mask array</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><p>define BitArray mask and operator</p><pre><code class="language-none">mask=falses(3)
mask[[1,3]]=true

A=joMask(mask)</code></pre><p>examples with RDT/DDT</p><pre><code class="language-none">A=joMask(mask; DDT=Float32)
A=joMask(mask; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joMask.jl#L51-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joMask-Union{Tuple{VDT}, Tuple{Integer,Array{VDT,1}}} where VDT&lt;:Integer" href="#JOLI.joMask-Union{Tuple{VDT}, Tuple{Integer,Array{VDT,1}}} where VDT&lt;:Integer"><code>JOLI.joMask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joMask(n,idx;[DDT=...,][RDT=...,][name=...])</code></pre><p>Mask operator with index array</p><p><strong>Signature</strong></p><pre><code class="language-none">function joMask(n::Integer,idx::Vector{VDT};
    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joMask&quot;) where {VDT&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>n</code>: size of square operator</li><li><code>idx</code>: vector of true indecies</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">A=joMask(3,[1,3])</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joMask(3,[1,3]; DDT=Float32)
A=joMask(3,[1,3]; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joMask.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joNFFT" href="#JOLI.joNFFT"><code>JOLI.joNFFT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joNFFT(N,nodes[,m=...][,sigma=...][,window=...][,K=...];
            [centered=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>1D NFFT transform over fast dimension (wrapper to https://github.com/tknopp/NFFT.jl)</p><p><strong>Signature</strong></p><pre><code class="language-none">function joNFFT(N::Integer,pos::Vector{joFloat},
    m=4,sigma=2.0,window=:kaiser_bessel,K=2000; centered::Bool=false,
    DDT::DataType=joComplex,RDT::DataType=DDT,name::String=&quot;joNFFT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>N</code>: size</li><li><code>nodes</code>: nodes&#39; positions</li><li>optional<ul><li>see https://github.com/tknopp/NFFT.jl for info about optional parameters to NFFTplan: <code>m</code>, <code>sigma</code>, <code>window</code>, and <code>K</code></li></ul></li><li>keywords<ul><li><code>centered</code>: return centered coefficients</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>NFFT always uses ComplexF64 vectors internally</li></ul><p><strong>Examples</strong></p><p>1D NFFT</p><pre><code class="language-none">joNFFT(N,nodes)</code></pre><p>centered coefficients</p><pre><code class="language-none">joNFFT(N,nodes; centered=true)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">% joNFFT(N,nodes; DDT=ComplexF32)
% joNFFT(N,nodes; DDT=ComplexF32,RDT=ComplexF64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joNFFT.jl#L38-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joOnes" href="#JOLI.joOnes"><code>JOLI.joOnes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joOnes(m[,n];[DDT=...,][RDT=...,][name=...])</code></pre><p>Operator equivalent to matrix of zerso</p><p><strong>Signature</strong></p><pre><code class="language-none">joOnes(m::Integer,n::Integer=m;
    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joOnes&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: size</li><li>optional<ul><li><code>n</code>: 2nd dimension if not square</li></ul></li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joOnes(m)
joOnes(m,n)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joOnes(m; DDT=Float32)
joOnes(m; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joOnes.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joOuterProd-Union{Tuple{VDT}, Tuple{UDT}, Tuple{Union{Union{Array{UDT,1}, SubArray{UDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,1} where Ti} where dA&lt;:(Array{UDT,N} where N), Union{Array{UDT,2}, LinearAlgebra.Adjoint{UDT,Array{UDT,2}}, LinearAlgebra.Transpose{UDT,Array{UDT,2}}, SubArray{UDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,2} where Ti} where dA&lt;:(Array{UDT,N} where N)},Union{Union{Array{VDT,1}, SubArray{VDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,1} where Ti} where dA&lt;:(Array{VDT,N} where N), Union{Array{VDT,2}, LinearAlgebra.Adjoint{VDT,Array{VDT,2}}, LinearAlgebra.Transpose{VDT,Array{VDT,2}}, SubArray{VDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,2} where Ti} where dA&lt;:(Array{VDT,N} where N)}}} where VDT&lt;:Number where UDT&lt;:Number" href="#JOLI.joOuterProd-Union{Tuple{VDT}, Tuple{UDT}, Tuple{Union{Union{Array{UDT,1}, SubArray{UDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,1} where Ti} where dA&lt;:(Array{UDT,N} where N), Union{Array{UDT,2}, LinearAlgebra.Adjoint{UDT,Array{UDT,2}}, LinearAlgebra.Transpose{UDT,Array{UDT,2}}, SubArray{UDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,2} where Ti} where dA&lt;:(Array{UDT,N} where N)},Union{Union{Array{VDT,1}, SubArray{VDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,1} where Ti} where dA&lt;:(Array{VDT,N} where N), Union{Array{VDT,2}, LinearAlgebra.Adjoint{VDT,Array{VDT,2}}, LinearAlgebra.Transpose{VDT,Array{VDT,2}}, SubArray{VDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,2} where Ti} where dA&lt;:(Array{VDT,N} where N)}}} where VDT&lt;:Number where UDT&lt;:Number"><code>JOLI.joOuterProd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joOuterProd(U,V;[DDT=...,][RDT=...,][name=...])</code></pre><p>Memory efficient implementation of operator A = U*V&#39;</p><p><strong>Signature</strong></p><pre><code class="language-none">joOuterProd(U::LocalVecOrMat{UDT},V::LocalVecOrMat{VDT};
    DDT::DataType=joFloat,RDT::DataType=promote_type(UDT,VDT,DDT),name::String=&quot;joOuterProd&quot;)
        where {UDT&lt;:Number,VDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>U</code>: left vector or matrix</li><li><code>V</code>: right vector or matrix</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>2nd dimension of U and V must match</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">A=joOuterProd(rand(4),rand(5))
A=joOuterProd(rand(4,2),rand(5,2))</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joOuterProd(rand(4),rand(5); DDT=Float32)
A=joOuterProd(rand(4),rand(5); DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joOuterProd.jl#L48-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joPermutation-Union{Tuple{Union{Array{T,1}, SubArray{T,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{T,Ti,1} where Ti} where dA&lt;:(Array{T,N} where N)}, Tuple{T}} where T&lt;:Integer" href="#JOLI.joPermutation-Union{Tuple{Union{Array{T,1}, SubArray{T,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{T,Ti,1} where Ti} where dA&lt;:(Array{T,N} where N)}, Tuple{T}} where T&lt;:Integer"><code>JOLI.joPermutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joPermutation(perm;[DDT=...,][RDT=...,][name=...])</code></pre><p>Permiutation operator</p><p><strong>Signature</strong></p><pre><code class="language-none">function joPermutation(perm::LocalVector{T};
    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joPermutation&quot;) where {T&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>perm</code>: permiutation vector</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joPermutation([3, 1, 2])</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joPermutation([3, 1, 2]; DDT=Float32)
joPermutation([3, 1, 2]; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joPermutation.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joReal-Tuple{Integer}" href="#JOLI.joReal-Tuple{Integer}"><code>JOLI.joReal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joReal(m;[VDP=...,][name=...])</code></pre><p>Takes real part of vector (experimantal).</p><p>transpose/adjont puts the real vector into real part of the complex vector with zero imag part</p><p><strong>Signature</strong></p><pre><code class="language-none">joReal(m::Integer;VDP::DataType=joFloat,name::String=&quot;joReal&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: vector size</li><li>keywords<ul><li><code>VDP</code>: float element type of Complex number in vector</li><li><code>name</code>: custom name</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joVecConvert.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joRestriction-Union{Tuple{idxdt}, Tuple{Integer,Union{Array{idxdt,1}, SubArray{idxdt,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{idxdt,Ti,1} where Ti} where dA&lt;:(Array{idxdt,N} where N)}} where idxdt&lt;:Integer" href="#JOLI.joRestriction-Union{Tuple{idxdt}, Tuple{Integer,Union{Array{idxdt,1}, SubArray{idxdt,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{idxdt,Ti,1} where Ti} where dA&lt;:(Array{idxdt,N} where N)}} where idxdt&lt;:Integer"><code>JOLI.joRestriction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joRestriction(n,idx;[makecopy=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>Restriction operator</p><p><strong>Signature</strong></p><pre><code class="language-none">function joRestriction(n::Integer,idx::LocalVector{idxdt};
    makecopy::Bool=true,DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joRestriction&quot;)
        where {idxdt&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>n</code>: number of columns</li><li><code>idx</code>: vector of indecies</li><li>keywords<ul><li><code>makecopy</code>: make private copy of indecies vector</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">A=joRestriction(3,[1,3])</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joRestriction(3,[1,3];DDT=Float32)
A=joRestriction(3,[1,3];DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joRestriction.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joRomberg-Tuple{Vararg{Integer,N} where N}" href="#JOLI.joRomberg-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joRomberg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joRomberg(n1[,n2[,...]];[DDT=...,][RDT=...,][name=...])</code></pre><p>A random comvolution based on Romberg 08</p><p><strong>Signature</strong></p><pre><code class="language-none">joRomberg(dims::Integer...;
    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joRomberg&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>n1[,n2[...]]</code>: dimensions of the image; M=N=prod(ni)</li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">A=joRomberg(9)
A=joRomberg(9,11)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">A=joRomberg(9,11; DDT=Float32)
A=joRomberg(9,11; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joRomberg.jl#L41-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number" href="#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joSAdistributedLinOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joSAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])</code></pre><p>Create a linear operator working on 2D SharedArray in multi-vector (over 2nd dimension) mode.</p><p><strong>Signature</strong></p><pre><code class="language-none">function joSAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);
    fclean::Bool=false,rclean::Bool=false) where {DDT&lt;:Number,RDT&lt;:Number,INT&lt;:Integer}
joSAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,
    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);
    fclean::Bool=false,rclean::Bool=false) where {ADDT&lt;:Number,ARDT&lt;:Number,INT&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: joAbstractLinearOperator type</li><li><code>nvc</code>: number of columns in multi-vector</li><li><code>parts</code>: custom partitioning of 2nd diemnsion </li><li><code>fclean</code>: close SharedArray after forward operation</li><li><code>rclean</code>: close SharedArray after forward operation in transpose/adjoint mode</li></ul><p><strong>Examples</strong></p><ul><li><code>joSAdistributedLinOp(A,30)</code>: operator that will apply A to distributed multivector with 30 columns</li></ul><p><strong>Notes</strong></p><ul><li>nvc must be &gt;= then # of workers in the WorkerPool</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractSAparallelLinearOperator/constructors.jl#L56-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number" href="#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joSAdistributedLinOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joSAdistributedLinOp(A,psin; [,fclean] [,rclean])</code></pre><p>Create a linear operator working on 2D SharedArray in multi-vector (over 2nd dimension) mode.</p><p><strong>Signature</strong></p><pre><code class="language-none">function joSAdistributedLinOp(A::joAbstractLinearOperator{DDT,RDT},psin::joPAsetup,
    fclean::Bool=false,rclean::Bool=false) where {DDT&lt;:Number,RDT&lt;:Number,INT&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: joAbstractLinearOperator type</li><li><code>psin</code>: parallel setup from jpPAsetup</li><li><code>fclean</code>: close SharedArray after forward operation</li><li><code>rclean</code>: close SharedArray after forward operation in transpose/adjoint mode</li></ul><p><strong>Examples</strong></p><ul><li><code>ps=joPAsetup((12,30))</code>: define parallel setup for operator with 12 columns and multi-vector with 30 columns</li><li><code>joSAdistributedLinOp(A,ps)</code>: operator that will apply A to distributed multi-vector with 30 columns</li></ul><p><strong>Notes</strong></p><ul><li>nvc of joPAsetup must be &gt;= then # of workers in the WorkerPool</li><li>DT in joPAsetup will be overwritten by DDT of the operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joAbstractSAparallelLinearOperator/constructors.jl#L9-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSWT" href="#JOLI.joSWT"><code>JOLI.joSWT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joSWT(m,[wt,];[L=...,][DDT=...,][RDT=...])</code></pre><p>1-dimensional SWT transform based on PyWavelets. Only 1D is supported currently in JOLI but n-dimensional supported in PyWavelets. Choice of wavelet is fixed to &quot;db20&quot;</p><p><strong>Signature</strong></p><pre><code class="language-none">function joSWT(m::Integer, wt::String=&quot;db20&quot;;
    L::Integer=maxtransformlevels(min(m,n)),
    DDT::DataType=joFloat,RDT::DataType=DDT,
    name::String=&quot;joDWT&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: dimention</li><li>optional<ul><li><code>wt</code>: wavelet filter (&quot;db20&quot; by default) see for options:</li></ul>https://github.com/PyWavelets/pywt/blob/master/pywt/<em>extensions/wavelets</em>list.pxi</li><li>keywords<ul><li><code>L</code>: number of levels</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>only 1D arrays are supported for now due to limitations of author time.</li><li>only orthogonal wavelets should be used from [&quot;haar&quot;, &quot;db&quot;, &quot;sym&quot;, &quot;coif&quot;] to have access to adjoint via inverse.</li></ul><p><strong>Examples</strong></p><p>1D DWT with default wavelet (Daubechie20 wavelet)</p><pre><code class="language-none">joSWT(m)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joDWT(m,&quot;db20&quot;; DDT=Float32)
joDWT(m,&quot;sym5&quot;; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearFunctionConstructors/joSWT.jl#L29-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joSincInterp-Union{Tuple{I}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#JOLI.joSincInterp-Union{Tuple{I}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>JOLI.joSincInterp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; joSincInterp(xin,xout;[r=...,][DDT=...,][RDT=...,][name=...])</code></pre><p>sinc interpolation matrix for interpolating functions f defined on grid xin to functions defined on grid xout</p><p><strong>Signature</strong></p><pre><code class="language-none">function joSincInterp(xin::AbstractArray{T,1},xout::AbstractArray{T,1};
    r::I=0,DDT::DataType=T,RDT::DataType=DDT,name::String=&quot;joSincInterp&quot;)
    where {T&lt;:AbstractFloat,I&lt;:Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>xin</code>  - 1D input grid</li><li><code>xout</code> - 1D output grid</li><li>keywords<ul><li><code>r</code>: kaiser window parameter (default: 0, no windowing)</li><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>If xout has more than one point, the spacings of xin and xout are normalized to the spacing of xout.</li></ul><p><strong>Examples</strong></p><p>% description</p><pre><code class="language-none">joSincInterp(xin,xout)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">% joSincInterp(xin,xout; DDT=Float32)
% joSincInterp(xin,xout; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joSincInterp.jl#L12-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joStack-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number" href="#JOLI.joStack-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joStack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joStack(op1[,op2][,...];[weights=...,][name=...])</code></pre><p>Stack operator (single block column) composed from different JOLI operators</p><p><strong>Signature</strong></p><pre><code class="language-none">joStack(ops::joAbstractLinearOperator...;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joStack&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>op#</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all operators must have the same # of columns (N)</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joStack are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operators</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)
b=rand(ComplexF64,8,4);
B=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=&quot;B&quot;)
c=rand(ComplexF64,6,4);
C=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=&quot;C&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic stack in function syntax</p><pre><code class="language-none">S=joStack(A,B,C)</code></pre><p>basic stack in [] syntax</p><pre><code class="language-none">S=[A; B; C]</code></pre><p>weighted stack</p><pre><code class="language-none">S=joStack(A,B,C;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joStack.jl#L14-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joStack-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number" href="#JOLI.joStack-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joStack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; op = joStack(l,op;[weights=...,][name=...])</code></pre><p>Stack operator composed from l-times replicated square JOLI operator</p><p><strong>Signature</strong></p><pre><code class="language-none">joStack(l::Integer,op::joAbstractLinearOperator;
    weights::LocalVector{WDT}=zeros(0),name::String=&quot;joStack&quot;)
        where {WDT&lt;:Number}</code></pre><p><strong>Arguments</strong></p><ul><li><code>l</code>: # of replcated blocks</li><li><code>op</code>: JOLI operators (subtypes of joAbstractLinearOperator)</li><li>keywords<ul><li><code>weights</code>: vector of waights for each operator</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>all operators must have the same # of columns (N)</li><li>all given operators must have same domain/range types</li><li>the domain/range types of joStack are equal to domain/range types of the given operators</li></ul><p><strong>Example</strong></p><p>define operator</p><pre><code class="language-none">a=rand(ComplexF64,4,4);
A=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=&quot;A&quot;)</code></pre><p>define weights if needed</p><pre><code class="language-none">w=rand(ComplexF64,3)</code></pre><p>basic stack</p><pre><code class="language-none">S=joStack(3,A)</code></pre><p>weighted stack</p><pre><code class="language-none">S=joStack(3,A;weights=w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joLinearOperatorConstructors/joCoreBlockConstructors/joStack.jl#L111-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.joZeros" href="#JOLI.joZeros"><code>JOLI.joZeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; op = joZeros(m[,n];[DDT=...,][RDT=...,][name=...])</code></pre><p>Operator equivalent to matrix of ones</p><p><strong>Signature</strong></p><pre><code class="language-none">joZeros(m::Integer,n::Integer=m;
    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=&quot;joZeros&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: size</li><li>optional<ul><li><code>n</code>: 2nd dimension if not square</li></ul></li><li>keywords<ul><li><code>DDT</code>: domain data type</li><li><code>RDT</code>: range data type</li><li><code>name</code>: custom name</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">joZeros(m)
joZeros(m,n)</code></pre><p>examples with DDT/RDT</p><pre><code class="language-none">joZeros(m; DDT=Float32)
joZeros(m; DDT=Float32,RDT=Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMatrixConstructors/joZeros.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_PAmode-Tuple{}" href="#JOLI.jo_PAmode-Tuple{}"><code>JOLI.jo_PAmode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>jo_PAmode - set and query parallel mode</p><p>jo_PAmode(verbose=false) - query parallel mode</p><p>jo_PAmode([ :SA | :DA ]; verbose=false) - set parallel mode to respectively shared or distributed arrays</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joPAmode.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_balanced_partition" href="#JOLI.jo_balanced_partition"><code>JOLI.jo_balanced_partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia&gt; jo_balanced_partition(nlabs::Integer,dsize::Integer)</code></pre><p>Get balanced partitioning of the dimension (dsize) on n workers (nlabs)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joMiscTypesMethods/joPAsetup.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_check_type_match-Tuple{DataType,DataType,String}" href="#JOLI.jo_check_type_match-Tuple{DataType,DataType,String}"><code>JOLI.jo_check_type_match</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check type match</p><pre><code class="language-none">jo_check_type_match(DT1::DataType,DT2::DataType,where::String)</code></pre><p>The bahaviour of the function while types do not match depends on values of jo<em>type</em>mismatch<em>warn and jo</em>type<em>mismatch</em>error flags. Use jo<em>type</em>mismatch<em>error</em>set to toggle those flags from warning mode to error mode.</p><p><strong>EXAMPLE</strong></p><ul><li>jo<em>check</em>type_match(Float32,Float64,&quot;my session&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L313-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_complex_eltype-Tuple{DataType}" href="#JOLI.jo_complex_eltype-Tuple{DataType}"><code>JOLI.jo_complex_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Type of element of complex data type</p><pre><code class="language-none">jo_complex_eltype(DT::DataType)</code></pre><p><strong>Example</strong></p><ul><li>jo<em>complex</em>eltype(ComplexF32)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L264-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_complex_eltype-Union{Tuple{Complex{T}}, Tuple{T}} where T" href="#JOLI.jo_complex_eltype-Union{Tuple{Complex{T}}, Tuple{T}} where T"><code>JOLI.jo_complex_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Type of element of complex scalar</p><pre><code class="language-none">jo_complex_eltype(a::Complex)</code></pre><p><strong>Example</strong></p><ul><li>jo<em>complex</em>eltype(1.+im*1.)</li><li>jo<em>complex</em>eltype(zero(ComplexF64))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L253-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_convert-Union{Tuple{NT}, Tuple{DataType,NT}, Tuple{DataType,NT,Bool}} where NT&lt;:Integer" href="#JOLI.jo_convert-Union{Tuple{NT}, Tuple{DataType,NT}, Tuple{DataType,NT,Bool}} where NT&lt;:Integer"><code>JOLI.jo_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert number to new type</p><pre><code class="language-none">jo_convert(DT::DataType,n::Number,warning::Bool=true)</code></pre><p><strong>Limitations</strong></p><ul><li>converting integer number to shorter representation will throw an error</li><li>converting float/complex number to integer will throw an error</li><li>converting from complex to float drops immaginary part and issues warning; use jo<em>convert</em>warn_set(false) to turn off the warning</li></ul><p><strong>Example</strong></p><ul><li>jo_convert(ComplexF32,rand())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L405-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_convert-Union{Tuple{VT}, Tuple{DataType,AbstractArray{VT,N} where N}, Tuple{DataType,AbstractArray{VT,N} where N,Bool}} where VT&lt;:Integer" href="#JOLI.jo_convert-Union{Tuple{VT}, Tuple{DataType,AbstractArray{VT,N} where N}, Tuple{DataType,AbstractArray{VT,N} where N,Bool}} where VT&lt;:Integer"><code>JOLI.jo_convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert vector to new type</p><pre><code class="language-none">jo_convert(DT::DataType,v::AbstractArray,warning::Bool=true)</code></pre><p><strong>Limitations</strong></p><ul><li>converting integer array to shorter representation will throw an error</li><li>converting float/complex array to integer will throw an error</li><li>converting from complex to float drops immaginary part and issues warning; use jo<em>convert</em>warn_set(false) to turn off the warning</li></ul><p><strong>Example</strong></p><ul><li>jo_convert(ComplexF32,rand(3))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L353-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_convert_warn_set-Tuple{Bool}" href="#JOLI.jo_convert_warn_set-Tuple{Bool}"><code>JOLI.jo_convert_warn_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set warning mode for jo_convert</p><pre><code class="language-none">jo_convert_warn_set(flag::Bool)</code></pre><p><strong>Example</strong></p><ul><li>jo<em>convert</em>warn_set(false) turns of the warnings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L339-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_eye" href="#JOLI.jo_eye"><code>JOLI.jo_eye</code></a> — <span class="docstring-category">Function</span></header><section><div><p>return identity array</p><pre><code class="language-none">jo_eye(m::Integer,n::Integer=m)
jo_eye(DT::DataType,m::Integer,n::Integer=m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_full-Tuple{AbstractArray}" href="#JOLI.jo_full-Tuple{AbstractArray}"><code>JOLI.jo_full</code></a> — <span class="docstring-category">Method</span></header><section><div><p>return full array</p><pre><code class="language-none">jo_full(A::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_iterative_solver4square_set-Tuple{Function}" href="#JOLI.jo_iterative_solver4square_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4square_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set default iterative solver for (jo,vec) and square jo</p><pre><code class="language-none">jo_iterative_solver4square_set(f::Function)</code></pre><p>Where f must take two arguments (jo,vec) and return vec.</p><p><strong>Example (using IterativeSolvers)</strong></p><ul><li>jo<em>iterative</em>solver4square_set((A,v)-&gt;gmres(A,v))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L182-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_iterative_solver4tall_set-Tuple{Function}" href="#JOLI.jo_iterative_solver4tall_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4tall_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set default iterative solver for (jo,vec) and tall jo</p><pre><code class="language-none">jo_iterative_solver4tall_set(f::Function)</code></pre><p>Where f must take two arguments (jo,vec) and return vec.</p><p><strong>Example</strong></p><ul><li>jo<em>iterative</em>solver4tall<em>set((A,v)-&gt;tall</em>solve(A,v))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L202-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_iterative_solver4wide_set-Tuple{Function}" href="#JOLI.jo_iterative_solver4wide_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4wide_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set default iterative solver for (jo,vec) and wide jo</p><pre><code class="language-none">jo_iterative_solver4wide_set(f::Function)</code></pre><p>Where f must take two arguments (jo,vec) and return vec.</p><p><strong>Example</strong></p><ul><li>jo<em>iterative</em>solver4wide<em>set((A,v)-&gt;wide</em>solve(A,v))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L222-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_jo32bit_set-Tuple{}" href="#JOLI.jo_jo32bit_set-Tuple{}"><code>JOLI.jo_jo32bit_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>set default type joInt, joFloat, joComplex to 32 bit</p><pre><code class="language-none">function jo_jo32bit_set()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_jo64bit_set-Tuple{}" href="#JOLI.jo_jo64bit_set-Tuple{}"><code>JOLI.jo_jo64bit_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>set default type joInt, joFloat, joComplex to 64 bit</p><pre><code class="language-none">function jo_jo64bit_set()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_joComplex_set" href="#JOLI.jo_joComplex_set"><code>JOLI.jo_joComplex_set</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set default complex type joComplex</p><pre><code class="language-none">function jo_joComplex_set(DT::DataType=joComplex)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_joFloat_set" href="#JOLI.jo_joFloat_set"><code>JOLI.jo_joFloat_set</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set default float type joFloat</p><pre><code class="language-none">function jo_joFloat_set(DT::DataType=joFloat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_joInt_set" href="#JOLI.jo_joInt_set"><code>JOLI.jo_joInt_set</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set default integer type joInt</p><pre><code class="language-none">function jo_joInt_set(DT::DataType=joInt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_joTypes_get-Tuple{}" href="#JOLI.jo_joTypes_get-Tuple{}"><code>JOLI.jo_joTypes_get</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get default types joInt, joFloat, joComplex</p><pre><code class="language-none">function jo_joTypes_get()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_precision_type-Union{Tuple{Tx}, Tuple{Tx}, Tuple{ITx}} where Tx&lt;:Union{Complex{ITx}, ITx} where ITx&lt;:Number" href="#JOLI.jo_precision_type-Union{Tuple{Tx}, Tuple{Tx}, Tuple{ITx}} where Tx&lt;:Union{Complex{ITx}, ITx} where ITx&lt;:Number"><code>JOLI.jo_precision_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Type of the real number or element type of complex number.</p><p><strong>Example</strong></p><ul><li>jo<em>precision</em>type(1.)</li><li>jo<em>precision</em>type(1+im*3.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L241-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_speye" href="#JOLI.jo_speye"><code>JOLI.jo_speye</code></a> — <span class="docstring-category">Function</span></header><section><div><p>return sparse identity array</p><pre><code class="language-none">jo_speye(m::Integer,n::Integer=m)
jo_speye(DT::DataType,m::Integer,n::Integer=m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_type_mismatch_error_set-Tuple{Bool}" href="#JOLI.jo_type_mismatch_error_set-Tuple{Bool}"><code>JOLI.jo_type_mismatch_error_set</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Toggle between warning and error for type mismatch</p><pre><code class="language-none">jo_type_mismatch_error_set(flag::Bool)</code></pre><p><strong>Examples</strong></p><ul><li>jo<em>type</em>mismatch<em>error</em>set(false) turns on warnings instead of errors</li><li>jo<em>type</em>mismatch<em>error</em>set(true) reverts to errors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L284-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.jo_type_tree" href="#JOLI.jo_type_tree"><code>JOLI.jo_type_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Show type tree of JOLI operators, or any type with editional Type argument.</p><pre><code class="language-none">jo_type_tree()
jo_type_tree(Number)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.salloc-Tuple{joPAsetup}" href="#JOLI.salloc-Tuple{joPAsetup}"><code>JOLI.salloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julia&gt; salloc(d; [DT])</code></pre><p>Allocates a SharedArray according to given distributor</p><p><strong>Signature</strong></p><pre><code class="language-none">salloc(d::joPAsetup;DT::DataType=d.DT)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>: see help for joPAsetup</li><li><code>DT</code>: keyword argument to overwrite the type in joPAsetup</li></ul><p><strong>Examples</strong></p><ul><li><code>salloc(d)</code>: allocate an array</li><li><code>salloc(d,DT=Float32)</code>: allocate array and overwite d.DT with Float32</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joExternalPackages/SharedArraysSupport.jl#L51-L70">source</a></section></article><h2 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h2><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JOLI.@joNF-Tuple{Expr}" href="#JOLI.@joNF-Tuple{Expr}"><code>JOLI.@joNF</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Nullable{Function} macro for given function</p><pre><code class="language-none">@joNF ... | @joNF(...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JOLI.@joNF-Tuple{}" href="#JOLI.@joNF-Tuple{}"><code>JOLI.@joNF</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Nullable{Function} macro for null function</p><pre><code class="language-none">@joNF</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JOLI.jl/blob/1b7a9c1d7524cbfd4ebd2db8eb8f757c30dff503/src/joUtils.jl#L161-L165">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#JOLI.JOLI"><code>JOLI.JOLI</code></a></li><li><a href="#JOLI.joCoreBlock-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WT}, Tuple{OT}} where WT&lt;:Number where OT&lt;:Integer"><code>JOLI.joCoreBlock</code></a></li><li><a href="#JOLI.joDALinearOperator"><code>JOLI.joDALinearOperator</code></a></li><li><a href="#JOLI.joDAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joDAdistribute</code></a></li><li><a href="#JOLI.joDAdistribute"><code>JOLI.joDAdistribute</code></a></li><li><a href="#JOLI.joDAdistributedLinearOperator"><code>JOLI.joDAdistributedLinearOperator</code></a></li><li><a href="#JOLI.joDAdistributingLinearOperator"><code>JOLI.joDAdistributingLinearOperator</code></a></li><li><a href="#JOLI.joDAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joDAgather</code></a></li><li><a href="#JOLI.joDAgather"><code>JOLI.joDAgather</code></a></li><li><a href="#JOLI.joDAgatheringLinearOperator"><code>JOLI.joDAgatheringLinearOperator</code></a></li><li><a href="#JOLI.joKron-Tuple{Vararg{joAbstractLinearOperator,N} where N}"><code>JOLI.joKron</code></a></li><li><a href="#JOLI.joLinearFunction"><code>JOLI.joLinearFunction</code></a></li><li><a href="#JOLI.joLinearFunctionInplace"><code>JOLI.joLinearFunctionInplace</code></a></li><li><a href="#JOLI.joLinearOperator"><code>JOLI.joLinearOperator</code></a></li><li><a href="#JOLI.joLooseLinearFunction"><code>JOLI.joLooseLinearFunction</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplace"><code>JOLI.joLooseLinearFunctionInplace</code></a></li><li><a href="#JOLI.joLooseMatrix"><code>JOLI.joLooseMatrix</code></a></li><li><a href="#JOLI.joLooseMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joLooseMatrix</code></a></li><li><a href="#JOLI.joLooseMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joLooseMatrixInplace</code></a></li><li><a href="#JOLI.joLooseMatrixInplace"><code>JOLI.joLooseMatrixInplace</code></a></li><li><a href="#JOLI.joMatrix"><code>JOLI.joMatrix</code></a></li><li><a href="#JOLI.joMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joMatrix</code></a></li><li><a href="#JOLI.joMatrixInplace"><code>JOLI.joMatrixInplace</code></a></li><li><a href="#JOLI.joMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT"><code>JOLI.joMatrixInplace</code></a></li><li><a href="#JOLI.joNumber-Union{Tuple{NT}, Tuple{NT}} where NT&lt;:Number"><code>JOLI.joNumber</code></a></li><li><a href="#JOLI.joNumber-Union{Tuple{RDT}, Tuple{DDT}, Tuple{NT}, Tuple{NT,joAbstractLinearOperator{DDT,RDT}}} where RDT where DDT where NT&lt;:Number"><code>JOLI.joNumber</code></a></li><li><a href="#JOLI.joNumber"><code>JOLI.joNumber</code></a></li><li><a href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Tuple{Vararg{INT,N} where N},N} where N}}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joPAsetup"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N,Integer}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joPAsetup-Tuple{DistributedArrays.DArray}"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}} where INT&lt;:Integer"><code>JOLI.joPAsetup</code></a></li><li><a href="#JOLI.joSALinearOperator"><code>JOLI.joSALinearOperator</code></a></li><li><a href="#JOLI.joSAdistribute"><code>JOLI.joSAdistribute</code></a></li><li><a href="#JOLI.joSAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joSAdistribute</code></a></li><li><a href="#JOLI.joSAdistributedLinearOperator"><code>JOLI.joSAdistributedLinearOperator</code></a></li><li><a href="#JOLI.joSAdistributingLinearOperator"><code>JOLI.joSAdistributingLinearOperator</code></a></li><li><a href="#JOLI.joSAgather"><code>JOLI.joSAgather</code></a></li><li><a href="#JOLI.joSAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT&lt;:Integer"><code>JOLI.joSAgather</code></a></li><li><a href="#JOLI.joSAgatheringLinearOperator"><code>JOLI.joSAgatheringLinearOperator</code></a></li><li><a href="#DistributedArrays.SPMD.scatter-Tuple{AbstractArray,joPAsetup}"><code>DistributedArrays.SPMD.scatter</code></a></li><li><a href="#DistributedArrays.dfill-Tuple{Number,joPAsetup}"><code>DistributedArrays.dfill</code></a></li><li><a href="#DistributedArrays.dfill-Tuple{Function,joPAsetup}"><code>DistributedArrays.dfill</code></a></li><li><a href="#DistributedArrays.distribute-Tuple{AbstractArray,joPAsetup}"><code>DistributedArrays.distribute</code></a></li><li><a href="#DistributedArrays.dones-Tuple{joPAsetup}"><code>DistributedArrays.dones</code></a></li><li><a href="#DistributedArrays.drand-Tuple{joPAsetup}"><code>DistributedArrays.drand</code></a></li><li><a href="#DistributedArrays.drandn-Tuple{joPAsetup}"><code>DistributedArrays.drandn</code></a></li><li><a href="#DistributedArrays.dzeros-Tuple{joPAsetup}"><code>DistributedArrays.dzeros</code></a></li><li><a href="#JOLI.dalloc-Tuple{joPAsetup}"><code>JOLI.dalloc</code></a></li><li><a href="#JOLI.dalloc-Tuple{Tuple{Vararg{Int64,N}} where N,Vararg{Any,N} where N}"><code>JOLI.dalloc</code></a></li><li><a href="#JOLI.dcopy-Union{Tuple{T}, Tuple{LinearAlgebra.Transpose{T,#s26} where #s26&lt;:(DistributedArrays.DArray{T,2,A} where A),joPAsetup}} where T"><code>JOLI.dcopy</code></a></li><li><a href="#JOLI.dparts-Union{Tuple{DistributedArrays.DArray{T,N,A} where A}, Tuple{N}, Tuple{T}} where N where T"><code>JOLI.dparts</code></a></li><li><a href="#JOLI.joAddSolverAll-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function,Function,Function,Function}} where RDT where DDT"><code>JOLI.joAddSolverAll</code></a></li><li><a href="#JOLI.joAddSolverAny-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function}} where RDT where DDT"><code>JOLI.joAddSolverAny</code></a></li><li><a href="#JOLI.joBlock-Union{Tuple{WDT}, Tuple{RVDT}, Tuple{Array{RVDT,1},Vararg{joAbstractLinearOperator,N} where N}} where WDT&lt;:Number where RVDT&lt;:Integer"><code>JOLI.joBlock</code></a></li><li><a href="#JOLI.joBlockDiag-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joBlockDiag</code></a></li><li><a href="#JOLI.joBlockDiag-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joBlockDiag</code></a></li><li><a href="#JOLI.joConj-Tuple{Integer}"><code>JOLI.joConj</code></a></li><li><a href="#JOLI.joConstants-Union{Tuple{EDT}, Tuple{Integer,EDT}} where EDT&lt;:Number"><code>JOLI.joConstants</code></a></li><li><a href="#JOLI.joConvert-Tuple{Integer,DataType,DataType}"><code>JOLI.joConvert</code></a></li><li><a href="#JOLI.joCurvelet2D-Tuple{Integer,Integer}"><code>JOLI.joCurvelet2D</code></a></li><li><a href="#JOLI.joCurvelet2DnoFFT-Tuple{Integer,Integer}"><code>JOLI.joCurvelet2DnoFFT</code></a></li><li><a href="#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joDAdistributedLinOp</code></a></li><li><a href="#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joDAdistributedLinOp</code></a></li><li><a href="#JOLI.joDCT-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joDCT</code></a></li><li><a href="#JOLI.joDFT-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joDFT</code></a></li><li><a href="#JOLI.joDWT"><code>JOLI.joDWT</code></a></li><li><a href="#JOLI.joDiag-Union{Tuple{Union{Array{EDT,1}, SubArray{EDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{EDT,Ti,1} where Ti} where dA&lt;:(Array{EDT,N} where N)}, Tuple{EDT}} where EDT"><code>JOLI.joDiag</code></a></li><li><a href="#JOLI.joDict-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joDict</code></a></li><li><a href="#JOLI.joDict-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joDict</code></a></li><li><a href="#JOLI.joDirac-Tuple{Integer}"><code>JOLI.joDirac</code></a></li><li><a href="#JOLI.joExtend-Tuple{Integer,Symbol}"><code>JOLI.joExtend</code></a></li><li><a href="#JOLI.joEye-Tuple{Integer,Integer}"><code>JOLI.joEye</code></a></li><li><a href="#JOLI.joEye-Tuple{Integer}"><code>JOLI.joEye</code></a></li><li><a href="#JOLI.joGaussian"><code>JOLI.joGaussian</code></a></li><li><a href="#JOLI.joImag-Tuple{Integer}"><code>JOLI.joImag</code></a></li><li><a href="#JOLI.joLinInterp1D-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T&lt;:AbstractFloat"><code>JOLI.joLinInterp1D</code></a></li><li><a href="#JOLI.joLinearFunctionAll"><code>JOLI.joLinearFunctionAll</code></a></li><li><a href="#JOLI.joLinearFunctionFwd"><code>JOLI.joLinearFunctionFwd</code></a></li><li><a href="#JOLI.joLinearFunctionFwd_A"><code>JOLI.joLinearFunctionFwd_A</code></a></li><li><a href="#JOLI.joLinearFunctionFwd_T"><code>JOLI.joLinearFunctionFwd_T</code></a></li><li><a href="#JOLI.joLinearFunctionInplaceAll"><code>JOLI.joLinearFunctionInplaceAll</code></a></li><li><a href="#JOLI.joLinearFunctionInplaceFwd"><code>JOLI.joLinearFunctionInplaceFwd</code></a></li><li><a href="#JOLI.joLinearFunctionInplaceFwd_A"><code>JOLI.joLinearFunctionInplaceFwd_A</code></a></li><li><a href="#JOLI.joLinearFunctionInplaceFwd_T"><code>JOLI.joLinearFunctionInplaceFwd_T</code></a></li><li><a href="#JOLI.joLinearFunctionInplace_A"><code>JOLI.joLinearFunctionInplace_A</code></a></li><li><a href="#JOLI.joLinearFunctionInplace_T"><code>JOLI.joLinearFunctionInplace_T</code></a></li><li><a href="#JOLI.joLinearFunction_A"><code>JOLI.joLinearFunction_A</code></a></li><li><a href="#JOLI.joLinearFunction_T"><code>JOLI.joLinearFunction_T</code></a></li><li><a href="#JOLI.joLooseLinearFunctionAll"><code>JOLI.joLooseLinearFunctionAll</code></a></li><li><a href="#JOLI.joLooseLinearFunctionFwd"><code>JOLI.joLooseLinearFunctionFwd</code></a></li><li><a href="#JOLI.joLooseLinearFunctionFwd_A"><code>JOLI.joLooseLinearFunctionFwd_A</code></a></li><li><a href="#JOLI.joLooseLinearFunctionFwd_T"><code>JOLI.joLooseLinearFunctionFwd_T</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplaceAll"><code>JOLI.joLooseLinearFunctionInplaceAll</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplaceFwd"><code>JOLI.joLooseLinearFunctionInplaceFwd</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplaceFwd_A"><code>JOLI.joLooseLinearFunctionInplaceFwd_A</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplaceFwd_T"><code>JOLI.joLooseLinearFunctionInplaceFwd_T</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplace_A"><code>JOLI.joLooseLinearFunctionInplace_A</code></a></li><li><a href="#JOLI.joLooseLinearFunctionInplace_T"><code>JOLI.joLooseLinearFunctionInplace_T</code></a></li><li><a href="#JOLI.joLooseLinearFunction_A"><code>JOLI.joLooseLinearFunction_A</code></a></li><li><a href="#JOLI.joLooseLinearFunction_T"><code>JOLI.joLooseLinearFunction_T</code></a></li><li><a href="#JOLI.joMask-Tuple{BitArray{1}}"><code>JOLI.joMask</code></a></li><li><a href="#JOLI.joMask-Union{Tuple{VDT}, Tuple{Integer,Array{VDT,1}}} where VDT&lt;:Integer"><code>JOLI.joMask</code></a></li><li><a href="#JOLI.joNFFT"><code>JOLI.joNFFT</code></a></li><li><a href="#JOLI.joOnes"><code>JOLI.joOnes</code></a></li><li><a href="#JOLI.joOuterProd-Union{Tuple{VDT}, Tuple{UDT}, Tuple{Union{Union{Array{UDT,1}, SubArray{UDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,1} where Ti} where dA&lt;:(Array{UDT,N} where N), Union{Array{UDT,2}, LinearAlgebra.Adjoint{UDT,Array{UDT,2}}, LinearAlgebra.Transpose{UDT,Array{UDT,2}}, SubArray{UDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,2} where Ti} where dA&lt;:(Array{UDT,N} where N)},Union{Union{Array{VDT,1}, SubArray{VDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,1} where Ti} where dA&lt;:(Array{VDT,N} where N), Union{Array{VDT,2}, LinearAlgebra.Adjoint{VDT,Array{VDT,2}}, LinearAlgebra.Transpose{VDT,Array{VDT,2}}, SubArray{VDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,2} where Ti} where dA&lt;:(Array{VDT,N} where N)}}} where VDT&lt;:Number where UDT&lt;:Number"><code>JOLI.joOuterProd</code></a></li><li><a href="#JOLI.joPermutation-Union{Tuple{Union{Array{T,1}, SubArray{T,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{T,Ti,1} where Ti} where dA&lt;:(Array{T,N} where N)}, Tuple{T}} where T&lt;:Integer"><code>JOLI.joPermutation</code></a></li><li><a href="#JOLI.joReal-Tuple{Integer}"><code>JOLI.joReal</code></a></li><li><a href="#JOLI.joRestriction-Union{Tuple{idxdt}, Tuple{Integer,Union{Array{idxdt,1}, SubArray{idxdt,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{idxdt,Ti,1} where Ti} where dA&lt;:(Array{idxdt,N} where N)}} where idxdt&lt;:Integer"><code>JOLI.joRestriction</code></a></li><li><a href="#JOLI.joRomberg-Tuple{Vararg{Integer,N} where N}"><code>JOLI.joRomberg</code></a></li><li><a href="#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joSAdistributedLinOp</code></a></li><li><a href="#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool}, Tuple{joAbstractLinearOperator{DDT,RDT},joPAsetup,Bool,Bool}} where INT&lt;:Integer where RDT&lt;:Number where DDT&lt;:Number"><code>JOLI.joSAdistributedLinOp</code></a></li><li><a href="#JOLI.joSWT"><code>JOLI.joSWT</code></a></li><li><a href="#JOLI.joSincInterp-Union{Tuple{I}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>JOLI.joSincInterp</code></a></li><li><a href="#JOLI.joStack-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT&lt;:Number"><code>JOLI.joStack</code></a></li><li><a href="#JOLI.joStack-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT&lt;:Number"><code>JOLI.joStack</code></a></li><li><a href="#JOLI.joZeros"><code>JOLI.joZeros</code></a></li><li><a href="#JOLI.jo_PAmode-Tuple{}"><code>JOLI.jo_PAmode</code></a></li><li><a href="#JOLI.jo_balanced_partition"><code>JOLI.jo_balanced_partition</code></a></li><li><a href="#JOLI.jo_check_type_match-Tuple{DataType,DataType,String}"><code>JOLI.jo_check_type_match</code></a></li><li><a href="#JOLI.jo_complex_eltype-Tuple{DataType}"><code>JOLI.jo_complex_eltype</code></a></li><li><a href="#JOLI.jo_complex_eltype-Union{Tuple{Complex{T}}, Tuple{T}} where T"><code>JOLI.jo_complex_eltype</code></a></li><li><a href="#JOLI.jo_convert-Union{Tuple{VT}, Tuple{DataType,AbstractArray{VT,N} where N}, Tuple{DataType,AbstractArray{VT,N} where N,Bool}} where VT&lt;:Integer"><code>JOLI.jo_convert</code></a></li><li><a href="#JOLI.jo_convert-Union{Tuple{NT}, Tuple{DataType,NT}, Tuple{DataType,NT,Bool}} where NT&lt;:Integer"><code>JOLI.jo_convert</code></a></li><li><a href="#JOLI.jo_convert_warn_set-Tuple{Bool}"><code>JOLI.jo_convert_warn_set</code></a></li><li><a href="#JOLI.jo_eye"><code>JOLI.jo_eye</code></a></li><li><a href="#JOLI.jo_full-Tuple{AbstractArray}"><code>JOLI.jo_full</code></a></li><li><a href="#JOLI.jo_iterative_solver4square_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4square_set</code></a></li><li><a href="#JOLI.jo_iterative_solver4tall_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4tall_set</code></a></li><li><a href="#JOLI.jo_iterative_solver4wide_set-Tuple{Function}"><code>JOLI.jo_iterative_solver4wide_set</code></a></li><li><a href="#JOLI.jo_jo32bit_set-Tuple{}"><code>JOLI.jo_jo32bit_set</code></a></li><li><a href="#JOLI.jo_jo64bit_set-Tuple{}"><code>JOLI.jo_jo64bit_set</code></a></li><li><a href="#JOLI.jo_joComplex_set"><code>JOLI.jo_joComplex_set</code></a></li><li><a href="#JOLI.jo_joFloat_set"><code>JOLI.jo_joFloat_set</code></a></li><li><a href="#JOLI.jo_joInt_set"><code>JOLI.jo_joInt_set</code></a></li><li><a href="#JOLI.jo_joTypes_get-Tuple{}"><code>JOLI.jo_joTypes_get</code></a></li><li><a href="#JOLI.jo_precision_type-Union{Tuple{Tx}, Tuple{Tx}, Tuple{ITx}} where Tx&lt;:Union{Complex{ITx}, ITx} where ITx&lt;:Number"><code>JOLI.jo_precision_type</code></a></li><li><a href="#JOLI.jo_speye"><code>JOLI.jo_speye</code></a></li><li><a href="#JOLI.jo_type_mismatch_error_set-Tuple{Bool}"><code>JOLI.jo_type_mismatch_error_set</code></a></li><li><a href="#JOLI.jo_type_tree"><code>JOLI.jo_type_tree</code></a></li><li><a href="#JOLI.salloc-Tuple{joPAsetup}"><code>JOLI.salloc</code></a></li><li><a href="#JOLI.@joNF-Tuple{}"><code>JOLI.@joNF</code></a></li><li><a href="#JOLI.@joNF-Tuple{Expr}"><code>JOLI.@joNF</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 9 August 2020 17:57">Sunday 9 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
